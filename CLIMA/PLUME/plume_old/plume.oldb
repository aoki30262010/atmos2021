c
c **********************************************************************
c
      program doplume

c     Drives the plume model in single-column standalone mode for
c     one "timestep". DOPLUME prompts for various quantities (heat and
c     vapor fluxes at surface, area and radii of plumes), 
c     calls the gcm subroutines PLUME (and REEVAP), and PLUME writes
c     results (vertical profiles) to stdout and fort.10. This sequence
c     loops until "-1" is entered at the prompt. For now REEVAP
c     doesn't do anything noticable since the results are written 
c     before it is called.

c     The output for each loop (see end of PLUME) consists of: 
c      (1) Echo of the prompted-for values.
c      (2) Vertical profiles on grid-box *boundaries* of plume values
c          (z*), interpolated large-scale variables (y*int),
c          large-scale fluxes (tplu,qplu), new large-scale water-vapor
c          field (newq), and calculated precipitation (zprec, mm/day).
c      (3) One more line showing the diagnosed pbl height (heipbl, in
c          meters) and mean T,q (y*) in the lowest several layers. 
c      (4) Another line is printed if the convective mixing would
c          produce any negative large-scale water vapor (newq<0).

c     Include files 'complume' and 'comsatplume' are needed in the
c     local directory. All other subroutines are included in this file.

c     Modifications to the PLUME and REEVAP gcm code are marked by
c     "ccur"/"cloc", where ccur marks a gcm-only statement and cloc
c     marks a standalone-only statement. These changes only affect
c     the setting of the prompted-for values, and the diagnostic
c     output. No changes are made to any gcm physics or parameters
c     except those prompted for in DOPLUME. The defaults for the plume
c     areas and radii (if blanks are entered) are the current gcm
c     values.

c-----------------------------------------------------------------------
      include 'complume'                                           !cloc
c-----------------------------------------------------------------------
      dimension 
     *  ytflx(plon,porec),        yqflx(plon,porec),
     *  yuflx(plon,porec),        yvflx(plon,porec),

     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  yu(plon,porec,plev),      yv(plon,porec,plev), 
     *  yps(plon,porec),          
     *  tracer(plon,porec,plev,ptrace),

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  fplumu(plon,porec,plev),  fplumv(plon,porec,plev),
     *  fplumtra(plon,porec,plev,ptrace),

     *  convpra(plon,porec,plev), convpr(plon,porec),
     *  strapra(plon,porec,plev), strapr(plon,porec),
     *  frain(plon,porec),        fsnow(plon,porec),

     *  ypm(plon,porec,plev),     ypl(plon,porec,plevp),
     *  ypthic(plon,porec,plev),
     *  ypmcap(plon,porec,plev),  yplcap(plon,porec,plevp)

      data iuout /10/

      dimension sigprof(nprof)
      data sigprof /
     *  .009, .025, .060, .110, .165, .245, 
     *  .355, .500, .664, .811, .926, .991 /
      dimension tprof(nprof), qprof(nprof)
      data tprof /
     * 230, 223, 208, 192, 204, 225, 248, 267, 282, 288, 294, 298/
      data qprof /
     * 0003, .001, .003, .01, .03, .1, .4, 1., 3.2, 9.5, 14.5, 14.0/

      dimension sig12(12), sig18(18), sigl18(18+1)
      data sig12 /
     *  .009, .025, .060, .110, .165, .245, 
     *  .355, .500, .664, .811, .926, .991 /
      data sig18 /
     *  .005, .013, .033, .064, .099, .139,
     *  .189, .251, .325, .409, .501, .598,
     *  .695, .787, .866, .929, .970, .993 /
      data sigl18 /
c    *  .003, .008, .022, .049, .083, .118,  !ccm2 has top at 3mb
     *  .000, .008, .022, .049, .083, .118,  !we may need top at 0 mb(?)
     *  .163, .219, .288, .367, .456, .551,
     *  .649, .744, .831, .903, .956, .985, 1.000 /

c-----------------------------------------------------------------------
      include 'comsatplume'                                        !cloc
c-----------------------------------------------------------------------

c        Set dimensions and physical constants

      nlon = plon
      norec = porec
      nlev = plev
      nlevp = plevp
      ntrace = ptrace

      dtime = 1800.
      twodt = 2.*dtime
      nstep = 0
      nrstrt = nstep

      cpair  = 1004.64
      gravit = 9.80616
      latvap = 2.5104e06
      latice = 3.336e5
      latsub = latvap + latice
      rair   = 287.04
      rh2o   = 4.61e2
      rhoh2o = 1.e3
      ch2o = 4.218e3
      cice = 2.106e3
      tmelt  = 273.16
      cappa  = rair/cpair
      zvir   = rh2o/rair -1.
      cpwv   = 1.81e3
      cpvir  = cpwv/cpair - 1.

      dtbud = dtime
      facbud = 1.

c        Set model grids

      do 1 ji=1,nlon
        along(ji) = ((ji-.5)/nlon) * 2. * 3.1415927
    1 continue

      do 2 jj=1,norec
        cosbud(jj) = 0.5/norec
    2 continue

      if (nlev.eq.12) then
        do 3 jk=1,nlev
          sig(jk) = sig12(jk)
    3   continue
        do 4 jk=2,nlev
          sigkmh(jk) = 0.5*(sig(jk-1)+sig(jk))
    4   continue
        sigkmh(1) = 0.
        sigkmh(nlev+1) = 1.

      else if (nlev.eq.18) then
        do 5 jk=1,nlev
          sig(jk) = sig18(jk)
    5   continue
        do 6 jk=1,nlevp
          sigkmh(jk) = sigl18(jk)
    6   continue
      endif

      sigipk(1) = 0.
      do 7 jk=1,nlev
        sigkpk(jk) = sig(jk)**cappa
        sigipk(jk+1) = sigkmh(jk+1)**cappa
        dsigma(jk) = sigkmh(jk+1) - sigkmh(jk)
    7 continue
      sigkpk(nlev+1) = 1.

c        Set mean-state profiles of temperature (tprof, deg K) and
c        water vapor (qprof, g/kg) on model-independent grid sigprof

      do 8 jkp=1,nprof
c       tprof(jkp) = 300.*(sigprof(jkp)**cappa)
c       qprof(jkp) = 1000*0.5*qstblf(tprof(jkp),sigprof(jkp)*1.e5)
        qprof(jkp) = min ( qprof(jkp),
     *                     1000*qstblf(tprof(jkp),sigprof(jkp)*1.e5) )
    8 continue

c       Interpolate to model vertical grid, and set "gcm" large-scale
c       fields yt, yq, yu, yv, converting yq to kg/kg.

      call vinterp (yt, sig, tprof, sigprof, nlon,norec,nlev,nprof)
      call vinterp (yq, sig, qprof, sigprof, nlon,norec,nlev,nprof)

      do 10 jk=1,nlev
        do 12 jj=1,norec
          do 14 ji=1,nlon
            yq(ji,jj,jk) = .001 * yq(ji,jj,jk)
            yu(ji,jj,jk) = 5.
            yv(ji,jj,jk) = 5.
   14     continue
   12   continue
   10 continue

c        Overall prompt/plume/write loop

c------------------------
      do 1000 iloop=1,100
c------------------------

c        Prompt for (note defaults):
c        xytflx= upwards surface heat flux  (W m-2)
c        xyqflx= upwards surface water vapor flux (mm/day)
c        xarea = fractional area of *initial* PBL plumes in lowest layer
c        xareo = fractional area of *new* plumes initiated in any layer
c        xradb = radius of *initial* PBL plumes in lowest layer (m)
c        xradt = max radius of *new* plumes initiated in any layer (m)
c                Actually the new plume radius depends on height and
c                increases from xradb to xradb+xradt (zrado, loop 205).

  500 write (*,501)
      read(*,502,err=500) xytflx, xyqflx, xarea, xareo, xradb, xradt
      if (xytflx.eq.-1.) stop
      if (xytflx.eq.0.) xytflx = 300.
      if (xyqflx.eq.0.) xyqflx = 3.
      if (xarea.eq.0.) xarea = .030
      if (xareo.eq.0.) xareo = .005
      if (xradb.eq.0.) xradb = 50.
      if (xradt.eq.0.) xradt = 500.
      write (*,503)    xytflx, xyqflx, xarea, xareo, xradb, xradt
      write (iuout,501)
      write (iuout,*)
      write (iuout,503) xytflx, xyqflx, xarea, xareo, xradb, xradt
  501 format(/39('-')/
     * ' ytflx  yqflx   area   areo  radb  radt')
  502 format(
     *    f6.0,  f7.0,  f7.0,  f7.0, f6.0, f6.0)
  503 format(
     *    f6.1,  f7.1,  f7.3,  f7.3, f6.0, f6.0)

c        Set or initialize remaining gcm arrays: surface pressure (yps),
c        surface fluxes (y*flx), hybrid-coord grid pressures (ypm,etc),
c        tracers, 3-D flux reservoirs (fplum*), 3-D condensation rates
c        (convpra,strapra), precipitation (convr,frain, etc).

      do 600 jj=1,norec
        do 602 ji=1,nlon
          yps(ji,jj) = 1.e5
          ytflx(ji,jj) = xytflx
          yqflx(ji,jj) = xyqflx/86400.
          yuflx(ji,jj) = .1
          yvflx(ji,jj) = .1

          psurf = 1.e5
          do 604 jk=1,nlev
            ypm(ji,jj,jk) = psurf*sig(jk)
            ypthic(ji,jj,jk) = psurf*dsigma(jk)
            ypmcap(ji,jj,jk) = sig(jk)**cappa
  604     continue
          do 606 jk=1,nlevp
            ypl(ji,jj,jk) = psurf*sigkmh(jk)
            yplcap(ji,jj,jk) = sigkmh(jk)**capppa
  606     continue
  602   continue
  600 continue

      dhcdst  = 0.
      dhcdcu  = 0.
      dhcdstr = 0.
      dhcdcur = 0.

      call zero (tracer,   nlon*norec*nlev*ntrace)
      call zero (fplumt,   nlon*norec*nlev)
      call zero (fplumq,   nlon*norec*nlev)
      call zero (fplumu,   nlon*norec*nlev)
      call zero (fplumv,   nlon*norec*nlev)
      call zero (fplumtra, nlon*norec*nlev*ntrace)
      call zero (qct2,     nlon*norec*nlev)
      call zero (convpra,  nlon*norec*nlev)
      call zero (convpr,   nlon*norec)
      call zero (strapra,  nlon*norec*nlev)
      call zero (strapr,   nlon*norec)
      call zero (frain,    nlon*norec)
      call zero (fsnow,    nlon*norec)
     
c        Plume convection

      call plume ( ytflx, yqflx, yuflx, yvflx, 
     *             yt, yq, yu, yv, tracer, ntrace,
     *             ypm, ypl, ypthic, ypmcap, yplcap,
     *             fplumt, fplumq, fplumu, fplumv, fplumtra,
     *             convpra)
   
c        Reevaporation of falling precip 
   
c     call reevap ( yt, yq, ypm, ypthic, convpra, 
c    *              fplumt, fplumq, convpr, frain, fsnow, 
c    *              dhcdcur, 1 )

c-------------
 1000 continue
c-------------

      stop
      end
C
C ***************************** PLUME ********************************
C
      subroutine plume ( ytflx, yqflx, yuflx, yvflx, 
     *                   yt, yq, yu, yv, tracer, ntrace,
     *                   ypm, ypl, ypthic, ypmcap, yplcap,
     *                   fplumt, fplumq, fplumu, fplumv, fplumtra,
     *                   convpra)

c     Does convection (both pbl and free in one call),
c     by solving a subgrid plume model. The main plume is initiated  
c     at the center of the lowest layer (ie, top of constant-flux layer)
c     with w,t,... values scaled depending on the surface heat/momentum
c     fluxes based on constant-flux scaling. 

c     For all layers except the bottom and top, a "new" plume originates
c     at the center of a model layer if it can rise to (or beyond) the
c     top of that layer. This plume is then merged with an ongoing 
c     single main plume if it exists, with the latter tracked from layer
c     boundary to layer boundary, forming a new single main plume 
c     incoming at the bottom of the next layer. Condensation can occur 
c     in either of these plumes, forming precipitation. 

c     The plume equations explicitly solve for plume w,theta,q,u,v where
c     all except w are perturbations from the ambient quantities. The
c     plume vertical finite-difference step is upwards from layer
c     boundary to layer boundary. These quantities, along with the plume
c     condensation amounts, then imply the large-scale fluxes at layer
c     boundaries and the large-scale precip and latent heat release.
c     The large-scale flux convergences are actually put in reservoirs
c     fplum* and released (see reserv, called from vdif) with a time 
c     scale of a few hours.

c     Lines beginning with "cloc" are to convert to standalone mode
c     for use with ./Plume/plume.f

c     supplied:
c     ytflx   = upward sensible heat flux from surface (W/m2)
c     yqflx   = upward h2o mass flux from surface (Kg/m2/s)
c     yuflx   = upward u-momentum flux from surface (N/m2)
c     yvflx   = upward v-momentum flux from surface (N/m2)
c     yt      = agcm temperatures
c     yq      = agcm specific humidity
c     yu      = agcm eastward  velocity
c     yv      = agcm northward velocity 
c     tracer  = agcm tracer fields
c     ntrace  = number of agcm tracer fields
c     ypm     = agcm mid-layer pressures
c     ypl     = agcm layer-boundary pressures
c     ypthic  = agcm layer pressure-thicknesses
c     ypmcap  = (ypm/surface pressure)**cappa
c     yplcap  = (ypl/surface pressure)**cappa

c     modified:
c     fplum*  = reservoirs of "flux convergence*time" in each agcm layer
c     convpra = convective condensation rate (3-D) (modified)

c----------------------------------------------------------------------
      include 'complume'                                          !cloc
c----------------------------------------------------------------------
      dimension 
     *  ytflx(plon,porec),        yqflx(plon,porec),
     *  yuflx(plon,porec),        yvflx(plon,porec),

     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  yu(plon,porec,plev),      yv(plon,porec,plev), 
     *  tracer(plon,porec,plev,ptrace),
     *  ypm(plon,porec,plev),     ypl(plon,porec,plevp),
     *  ypthic(plon,porec,plev),
     *  ypmcap(plon,porec,plev),  yplcap(plon,porec,plevp),

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  fplumu(plon,porec,plev),  fplumv(plon,porec,plev),
     *  fplumtra(plon,porec,plev,ptrace),

     *  convpra(plon,porec,plev)

      dimension
     *  yh(plon,plev),     yrho(plon,plev),

     *  yhint(plon,plevp), yqint(plon,plevp), 
     *  yuint(plon,plevp), yvint(plon,plevp), 
     *  yrhoint(plon,plevp),
     *  yaint(plon,plevp,ptrace),

     *  dz(plon,plev),     dztot(plon,plev),
     *  dhdz(plon,plev),   dqdz(plon,plev),
     *  dudz(plon,plev),   dvdz(plon,plev),
     *  dadz(plon,plev,ptrace),

     *  dz2(plon,plev),
     *  dhdz2(plon,plev),  dqdz2(plon,plev),
     *  dudz2(plon,plev),  dvdz2(plon,plev),
     *  dadz2(plon,plev,ptrace)

      dimension
     *  zh(plon,plevp),    zq(plon,plevp), 
     *  zu(plon,plevp),    zv(plon,plevp),    
     *  zw(plon,plevp),    zws(plon,plevp),
     *  zt(plon,plevp),    zrho(plon,plevp),
     *  za(plon,plevp,ptrace),

     *  zh2(plon),         zq2(plon), 
     *  zu2(plon),         zv2(plon),    
     *  zw2(plon),         zws2(plon),
     *  zt2(plon),         zrho2(plon),
     *  zprec2(plon),      zlath2(plon),
     *  za2(plon,ptrace),

     *  zprec(plon,plev),  zlath(plon,plev),

     *  tplu(plon,plevp),  qplu(plon,plevp), 
     *  uplu(plon,plevp),  vplu(plon,plevp),
     *  aplu(plon,plevp,ptrace)

      dimension
     *  zarea(plon,plevp), zrad(plon,plevp),
     *  zareo(plon),       zrado(plon),

     *  zent(plon),        zdrag(plon),
     *  zento(plon),       zdrago(plon),

     *  zaold(plon),       zanew(plon),
     *  zwold(plon),       zwnew(plon)

      dimension
     *  heip03(plon,porec),heip15(plon,porec),
     *  ifpbl(plon),       heipbl(plon),
     *  laypbl(plon),      numpbl(plev),
     *  layplu(plon),      numplu(plev)
      character*3 chaplu(plev)
      save heip03, heip15

c     Diagnostic only:
      dimension qrat(plev), nqrat(plev), qneg(plev), nqneg(plev)
ccur  parameter (nprinz=1)                                         !ccur
      parameter (nprinz=2)                                         !cloc
      dimension iuprinz(nprinz)

      parameter (pi = 3.14159265358979)
c ---------------------------------------------------------------------
ccur$CALL SFEST
c ---------------------------------------------------------------------
      include 'comsatplume'                                       !cloc
c ---------------------------------------------------------------------
c        Initialize local diagnostics

      zptot = 0.
      zetot = 0.
      zqtot = 0.
      call reseti (numpbl, nlev, 0)
      call reseti (numplu, nlev, 0)

c        Set longitude indices at which local time is 03:00h or 15:00h,
c        for history pbl heights at those times

      do 20 ji=1,nlon
        tlocal = amod (nstep*dtime + 86400.*along(ji)/(2.*pi), 86400.)
        if (abs(tlocal- 3.00*3600.).le.0.5*86400./nlon +1.) ji03 = ji
        if (abs(tlocal-15.00*3600.).le.0.5*86400./nlon +1.) ji15 = ji
   20 continue

c        Overall loop over latitude

c=======================
      do 1000 jj=1,norec
c=======================

c         Calculate ambient pot.temp and density at layer midpoints

      do 100 jk=1,nlev
        do 102 ji=1,nlon
          yh(ji,jk) = yt(ji,jj,jk) / ypmcap(ji,jj,jk)
          yrho(ji,jk) = ypm(ji,jj,jk)
     *                / (rair*(1.+zvir*yq(ji,jj,jk))*yt(ji,jj,jk))
  102   continue
  100 continue

c        Interpolate ambient quantities to layer boundaries

      do 110 jk=1,nlevp
        if (jk.eq.1 .or. jk.eq.nlevp) then

          jkm = max (jk-1,1)
          do 112 ji=1,nlon
            yhint(ji,jk) = yh(ji,jkm)
            yqint(ji,jk) = yq(ji,jj,jkm)
            yuint(ji,jk) = yu(ji,jj,jkm)
            yvint(ji,jk) = yv(ji,jj,jkm)
            yrhoint(ji,jk)= yrho(ji,jkm)
  112     continue
          do 1120 n=1,ntrace
            do 1122 ji=1,nlon
              yaint(ji,jk,n) = tracer(ji,jj,jkm,n)
 1122       continue
 1120     continue

        else

          wei = (sig(jk)-sigkmh(jk)) / (sig(jk)-sig(jk-1))
          do 114 ji=1,nlon
            yhint(ji,jk) = wei*yh(ji,jk-1)    + (1.-wei)*yh(ji,jk)
            yqint(ji,jk) = wei*yq(ji,jj,jk-1) + (1.-wei)*yq(ji,jj,jk)
            yuint(ji,jk) = wei*yu(ji,jj,jk-1) + (1.-wei)*yu(ji,jj,jk)
            yvint(ji,jk) = wei*yv(ji,jj,jk-1) + (1.-wei)*yv(ji,jj,jk)
            yrhoint(ji,jk) = ypl(ji,jj,jk)
     *                     / ( rair*(1.+zvir*yqint(ji,jk))
     *                             *yhint(ji,jk)*yplcap(ji,jj,jk) )
  114     continue
          do 1140 n=1,ntrace
            do 1142 ji=1,nlon
              yaint(ji,jk,n) =     wei *tracer(ji,jj,jk-1,n)
     *                       + (1.-wei)*tracer(ji,jj,jk,n)
 1142       continue
 1140     continue

        endif
  110 continue
          
c        Compute ambient dz, d*/dz for full layers. For bottom layer,
c        just use top half of layer.

      do 120 jk=1,nlev
        do 122 ji=1,nlon
          dztot(ji,jk) = ypthic(ji,jj,jk) / (gravit*yrho(ji,jk))
          if (jk.eq.nlev) then
            dz(ji,jk) = dztot(ji,jk) * (sig(jk)-sigkmh(jk))/dsigma(jk)
          else
            dz(ji,jk) = dztot(ji,jk)
          endif
          dhdz(ji,jk) = (yhint(ji,jk)-yhint(ji,jk+1)) / dz(ji,jk)
          dqdz(ji,jk) = (yqint(ji,jk)-yqint(ji,jk+1)) / dz(ji,jk)
          dudz(ji,jk) = (yuint(ji,jk)-yuint(ji,jk+1)) / dz(ji,jk)
          dvdz(ji,jk) = (yvint(ji,jk)-yvint(ji,jk+1)) / dz(ji,jk)
  122   continue

        do 1220 n=1,ntrace
          do 1222 ji=1,nlon
            dadz(ji,jk,n) = (yaint(ji,jk,n)-yaint(ji,jk+1,n)) /dz(ji,jk)
 1222     continue
 1220   continue
  120 continue
          
c        Compute ambient dz and d*/dz for top halves of layers

      do 130 jk=1,nlev
        do 132 ji=1,nlon
          dz2(ji,jk)   = dztot(ji,jk) * (sig(jk)-sigkmh(jk))/dsigma(jk)
          dhdz2(ji,jk) = (yhint(ji,jk)-yh(ji,jk))    / dz2(ji,jk)
          dqdz2(ji,jk) = (yqint(ji,jk)-yq(ji,jj,jk)) / dz2(ji,jk)
          dudz2(ji,jk) = (yuint(ji,jk)-yu(ji,jj,jk)) / dz2(ji,jk)
          dvdz2(ji,jk) = (yvint(ji,jk)-yv(ji,jj,jk)) / dz2(ji,jk)
  132   continue

        do 1320 n=1,ntrace
          do 1322 ji=1,nlon
            dadz2(ji,jk,n) = (yaint(ji,jk,n)-tracer(ji,jj,jk,n))
     *                     / dz2(ji,jk)
 1322     continue
 1320   continue
  130 continue

c        Initialize all plume variables to zero, and diagnostic
c        plume-top locations to lowest layer

      call zero (zw,   nlon*nlevp)
      call zero (zws,  nlon*nlevp)
      call zero (zt,   nlon*nlevp)
      call zero (zh,   nlon*nlevp)
      call zero (zq,   nlon*nlevp)
      call zero (zu,   nlon*nlevp)
      call zero (zv,   nlon*nlevp)
      call zero (zrho, nlon*nlevp)
      call zero (za,   nlon*nlevp*ntrace)
      call zero (zarea,nlon*nlevp)
      call zero (zlath,nlon*nlev)
      call zero (zprec,nlon*nlev)

      do 140 ji=1,nlon
        ifpbl(ji) = 1
        heipbl(ji) = dztot(ji,nlev)-dz2(ji,nlev)
        laypbl(ji) = nlev
        layplu(ji) = nlev
  140 continue

c       Initialize main plume conditions at midpoint of bottom layer 
c       based on surface fluxes from constant-flux layer. But if net
c       buoyancy flux (ytflx/cp+.622*yqflx) is < 0, leave plume = zero.

      do 150 ji=1,nlon

c       zz = max (0., min (1., ytflx(ji,jj)/500. ))
c       zarea(ji,nlevp) = (1.-zz)*.005 + zz*.010 
c       zarea(ji,nlevp) = .010
c       zarea(ji,nlevp) = .005
ccur    zarea(ji,nlevp) = .030                                     !ccur
        zarea(ji,nlevp) = xarea                                    !cloc

        if (ytflx(ji,jj)/cpair+.622*yqflx(ji,jj).gt.0.) then

          ztau = sqrt (yuflx(ji,jj)**2 + yvflx(ji,jj)**2)
          ztauv = max (.01, sqrt(ztau/yrho(ji,nlev)) )
          zconv = ( (max(ytflx(ji,jj),0.)/(yrho(ji,nlev)*cpair))
     *              * rair * (1.-sig(nlev))
     *            ) ** (1./3.)
c-----
c old:
c         zwt = ytflx(ji,jj) / (cpair*yrho(ji,nlev)*zarea(ji,nlevp))
c         zw(ji,nlevp) = max (ztauv, (abs(zwt))**(1./3.))
c         zt(ji,nlevp) = zwt / zw(ji,nlevp)
c         if (abs(zt(ji,nlevp)).gt.10.) then
c           zt(ji,nlevp) = min (10., max(-10., zt(ji,nlevp)))
c           zw(ji,nlevp) = zwt / zt(ji,nlevp)
c         endif
c         zmass = zarea(ji,nlevp) * yrho(ji,nlev) * zw(ji,nlevp)
c         zq(ji,nlevp) = yqflx(ji,jj) / zmass
c         zu(ji,nlevp) = yuflx(ji,jj) / zmass
c         zv(ji,nlevp) = yvflx(ji,jj) / zmass
c-----
c new:
          zfac = 1. / zarea(ji,nlevp)
          zwt = ytflx(ji,jj) / (yrho(ji,nlev)*cpair)
          zw(ji,nlevp) = sqrt(zfac) * max(ztauv,zconv) 
          zt(ji,nlevp) = zfac*zwt / zw(ji,nlevp)
          if (abs(zt(ji,nlevp)).gt.10.) then
            zt(ji,nlevp) = min (10., max(-10., zt(ji,nlevp)))
            zw(ji,nlevp) = zfac*zwt / zt(ji,nlevp)
          endif
          zq(ji,nlevp)= zfac*yqflx(ji,jj) / (yrho(ji,nlev)*zw(ji,nlevp))
          zu(ji,nlevp)= zfac*yuflx(ji,jj) / (yrho(ji,nlev)*zw(ji,nlevp))
          zv(ji,nlevp)= zfac*yvflx(ji,jj) / (yrho(ji,nlev)*zw(ji,nlevp))

          zh(ji,nlevp) = zt(ji,nlevp) / ypmcap(ji,jj,nlev)
          zws(ji,nlevp)= zw(ji,nlevp)**2
          zrho(ji,nlevp)= ypm(ji,jj,nlev)
     *                  / ( rair*(1.+zvir*(zq(ji,nlevp)+yq(ji,jj,nlev)))
     *                          *(zt(ji,nlevp)+yt(ji,jj,nlev)) )

        endif
  150 continue

c        Integrate plumes upwards through each layer (except top one)

c------------------------
      do 200 jk=nlev,2,-1
c------------------------

        jkp = jk+1

c          Set plume properties. For new plumes (*o), the fractional
c          area is prescribed. For the main plume, the area (zarea)
c          have been determined from the surface-flux initialization
c          for the bottom layer (do loop 150), or from the merging at
c          the top of the previous layer (do loop 235). The main-plume
c          radius (zrad) is set for the bottom layer (ie, sfc-flux
c          thermals), and thereafter is determined by averaging its
c          value with new plumes (do loop 235). The area and radius of
c          new plumes  (zareo, zrado) are prescribed and can depend on 
c          height (sigma). Nb: plume radius affects the physics only
c          via the entrainment and drag coefficients zent[o],zdrag[o].

        if (jkp.eq.nlevp) then
          do 202 ji=1,nlon
ccur        zrad(ji,nlevp) = 50.                                   !ccur
            zrad(ji,nlevp) = xradb                                 !cloc
  202     continue
        endif

        do 205 ji=1,nlon

c         zareo(ji) = .003
c         zrado(ji) = max (100.,min (1000., .05*8000.*log(1./sig(jk)) ))

c         zareo(ji) = .010
c         zrado(ji) = 500. + max(0.,min(1.,(1.-sig(jk))/.5))*2000.
c         zrado(ji) = max (100., min (2000., 8000.*log(1./sig(jk))))

c         zareo(ji) = .010
c         zrado(ji) = 100. + max(0.,min(1.,(1.-sig(jk))/.7))*1000.

ccur      zareo(ji) = .005                                         !ccur
ccur      zrado(ji) = 50. + max(0.,min(1.,(1.-sig(jk))/.7))*1000.  !ccur
          zareo(ji) = xareo                                        !cloc
          zrado(ji) = xradb+ max(0.,min(1.,(1.-sig(jk))/.7))*xradt !cloc

          zent(ji)  = 0.05/zrad(ji,jkp)
          zdrag(ji) = 0.5/(pi*zrad(ji,jkp))
          zento(ji) = 0.05/zrado(ji)
          zdrago(ji)= 0.5/(pi*zrado(ji))
  205   continue

c          Integrate main plume (from below) through current layer

        do 210 ji=1,nlon
          if (zw(ji,jkp).gt.0.) then
            zexp = exp(-zent(ji)*dz(ji,jk))
            zh(ji,jk)= zh(ji,jkp)*zexp -(dhdz(ji,jk)/zent(ji))*(1.-zexp)
            zq(ji,jk)= zq(ji,jkp)*zexp -(dqdz(ji,jk)/zent(ji))*(1.-zexp)
            zu(ji,jk)= zu(ji,jkp)*zexp -(dudz(ji,jk)/zent(ji))*(1.-zexp)
            zv(ji,jk)= zv(ji,jkp)*zexp -(dvdz(ji,jk)/zent(ji))*(1.-zexp)
            zt(ji,jk)= zh(ji,jk)*yplcap(ji,jj,jk)

c              Test for parcel saturation, and condense amount that 
c              results in exactly saturated air. Store amount in zprec.
c              zlath is latent heat of condensation, determined by
c              ambient level temperature (ie, rain or snow), plus
c              correction for specific heats to be consistent with lsx
c              (imagining all phase changes occur at tmelt).

            delqn = 0.
            ztabs = (zh(ji,jk)+yhint(ji,jk))*yplcap(ji,jj,jk)
            zqabs = (zq(ji,jk)+yqint(ji,jk))
            zqsat = qstblf (ztabs, ypl(ji,jj,jk))
            if (zqabs.gt.zqsat) then
              zlath(ji,jk) = cvmgt ( latvap + cpwv*(ztabs-tmelt)
     *                               - ch2o*(yt(ji,jj,jk)-tmelt),
     *                               latsub + cpwv*(ztabs-tmelt)
     *                               - cice*(yt(ji,jj,jk)-tmelt),
     *                               yt(ji,jj,jk).ge.tmelt )
              dqz = (zlath(ji,jk)/rh2o) * zqsat / (ztabs**2)
              cpz = cpair*(1.+cpvir*zqabs)
              delq = (zqabs-zqsat) / (1.+dqz*zlath(ji,jk)/cpz)
              delqn = delq / (1.-zqabs)
              zqnew = zqabs - delq
              ztnew = ztabs + delqn*zlath(ji,jk)
     *                        / (cpair*(1.+cpvir*zqnew))
              zq(ji,jk) = zqnew - yqint(ji,jk)
              zh(ji,jk) = ztnew/yplcap(ji,jj,jk) - yhint(ji,jk)
              zt(ji,jk) = zh(ji,jk)*yplcap(ji,jj,jk)
            endif

            zrho(ji,jk) = ypl(ji,jj,jk)
     *                  / ( rair*(1.+zvir*(zq(ji,jk)+yqint(ji,jk)))
     *                      *(zh(ji,jk)+yhint(ji,jk))*yplcap(ji,jj,jk) )

            drho0 = gravit * (yrhoint(ji,jkp)-zrho(ji,jkp))/zrho(ji,jkp)
            drho1 = gravit * (yrhoint(ji,jk) -zrho(ji,jk) )/zrho(ji,jk) 
            a_rho =  (drho0 + (drho1-drho0)/(1.-zexp)) / zent(ji)
            b_rho = -(        (drho1-drho0)/(1.-zexp)) / zent(ji)

            zexp2 = zexp*zexp
c           or: include vertical drag
c           zexp2 = exp(-2.*(zent(ji)+zdrag(ji))*dz(ji,jk))
c           a_rho = a_rho* zent(ji) / (zent(ji)+zdrag(ji))
c           b_rho = b_rho* zent(ji) / (2.*(zent(ji)+zdrag(ji))-zent(ji))

            zws(ji,jk) = zws(ji,jkp)*zexp2
     *                 + a_rho*(1.-zexp2) + 2.*b_rho*(zexp-zexp2)
            zw(ji,jk) = sqrt ( max(zws(ji,jk),0.) )


c              If vertical velocity = 0, end of main plume;
c              else, re-compute zu and zv for (non-linear) form drag

            if (zw(ji,jk).eq.0.) then
              zh(ji,jk) = 0.
              zq(ji,jk) = 0.
              zu(ji,jk) = 0.
              zv(ji,jk) = 0.
              zt(ji,jk) = 0.
              zrho(ji,jk) = 0.
              zarea(ji,jk) = 0.
              zprec(ji,jk) = 0.
              zlath(ji,jk) = 0.

c             Either:
c             heipbl(ji) = heipbl(ji) + dz(ji,jk) * zws(ji,jkp)
c    *                   / (zws(ji,jkp) - min(zws(ji,jk),0.))
c             Or:
c             Solve quadratic eqn for exp(-zent*z), ie, for z where w=0,
c             for accurate increment to plume height (diagnostic only).
c             Only valid for no vertical drag (if commented out above).
c             Cvmgt(zz1) mod is a fudge to avoid quadratic singularity.
              zz1 = zws(ji,jkp) - a_rho - 2.*b_rho
              zz1 = cvmgt (zz1, zz1+1.e-9, abs(zz1).gt.1.e-10)
              zz2 = ( -b_rho + sqrt(b_rho**2-zz1*a_rho) ) / zz1
              heipbl(ji) = cvmgt (heipbl(ji) - alog(zz2)/zent(ji), 
     *                            heipbl(ji), ifpbl(ji).eq.1)

              laypbl(ji) = cvmgt (jk, laypbl(ji), ifpbl(ji).eq.1)
              layplu(ji) = jk
              ifpbl(ji) = 0
              zws(ji,jk) = 0.

            else

              zenu= zent(ji) + zdrag(ji)*abs(0.5*(zu(ji,jkp)+zu(ji,jk)))
     *                         / (0.5*(zw(ji,jkp)+zw(ji,jk)))
              zenv= zent(ji) + zdrag(ji)*abs(0.5*(zv(ji,jkp)+zv(ji,jk)))
     *                         / (0.5*(zw(ji,jkp)+zw(ji,jk)))
              zexu  = exp(-zenu*dz(ji,jk))
              zexv  = exp(-zenv*dz(ji,jk))
              zu(ji,jk) = zu(ji,jkp)*zexu - (dudz(ji,jk)/zenu)*(1.-zexu)
              zv(ji,jk) = zv(ji,jkp)*zexv - (dvdz(ji,jk)/zenv)*(1.-zexv)

c             Apply continuity condition (detrainment >= 0), imagining
c             plume consists of spherical bubbles with varying vertical
c             spacing mimicked by varying zarea
              zz = (zrho(ji,jkp)*zw(ji,jkp)) / (zrho(ji,jk)*zw(ji,jk))
              zarea(ji,jk) = zarea(ji,jkp) * min (1., zz/zexp)

              zprec(ji,jk) = zarea(ji,jk)*zrho(ji,jk)*zw(ji,jk)*delqn

              heipbl(ji) = cvmgt (heipbl(ji) + dz(ji,jk),
     *                            heipbl(ji), ifpbl(ji).eq.1)
            endif
          endif
  210   continue

c          In same way, integrate main-plume tracers through curr layer

        do 2100 n=1,ntrace
          do 2102 ji=1,nlon
            if (zw(ji,jkp).gt.0. .and. zw(ji,jk).gt.0.) then
              zexp = exp(-zent(ji)*dz(ji,jk))
              za(ji,jk,n) = za(ji,jkp,n)*zexp
     *                    - (dadz(ji,jk,n)/zent(ji))*(1.-zexp)
            else
              za(ji,jk,n) = 0.
            endif
 2102     continue
 2100   continue
              
c          Integrate new plume starting from mid-point of current layer.
 
        do 230 ji=1,nlon
          zexp = exp(-zento(ji)*dz2(ji,jk))
          zh2(ji) = -(dhdz2(ji,jk)/zento(ji))*(1.-zexp)
          zq2(ji) = -(dqdz2(ji,jk)/zento(ji))*(1.-zexp)
          zu2(ji) = -(dudz2(ji,jk)/zento(ji))*(1.-zexp)
          zv2(ji) = -(dvdz2(ji,jk)/zento(ji))*(1.-zexp)
          zt2(ji) = zh2(ji)*yplcap(ji,jj,jk)

c            Test for saturation as for main plume above

          delqn = 0.
          zprec2(ji) = 0.
          zlath2(ji) = 0.

          ztabs = (zh2(ji)+yhint(ji,jk))*yplcap(ji,jj,jk)
          zqabs = (zq2(ji)+yqint(ji,jk))
          zqsat = qstblf (ztabs, ypl(ji,jj,jk))
          if (zqabs.gt.zqsat) then
            zlath2(ji) = cvmgt ( latvap + cpwv*(ztabs-tmelt)
     *                           - ch2o*(yt(ji,jj,jk)-tmelt),
     *                           latsub + cpwv*(ztabs-tmelt)
     *                           - cice*(yt(ji,jj,jk)-tmelt),
     *                           yt(ji,jj,jk).ge.tmelt )
            dqz = (zlath2(ji)/rh2o) * zqsat / (ztabs**2)
            cpz = cpair*(1.+cpvir*zqabs)
            delq = (zqabs-zqsat) / (1.+dqz*zlath2(ji)/cpz)
            delqn = delq / (1.-zqabs)
            zqnew = zqabs - delq
            ztnew = ztabs + delqn*zlath2(ji)
     *                      / (cpair*(1.+cpvir*zqnew))
            zq2(ji) = zqnew - yqint(ji,jk)
            zh2(ji) = ztnew/yplcap(ji,jj,jk) - yhint(ji,jk)
            zt2(ji) = zh2(ji)*yplcap(ji,jj,jk)
          endif

          zrho2(ji) = ypl(ji,jj,jk)
     *              / ( rair*(1.+zvir*(zq2(ji)+yqint(ji,jk)))
     *                      *(zh2(ji)+yhint(ji,jk))*yplcap(ji,jj,jk) )

          drho = gravit * (yrhoint(ji,jk)-zrho2(ji))/zrho2(ji)

          zws2(ji) = (drho/zento(ji))*(1.-zexp)
c         or: include vertical drag
c         zexp2 = exp(-2.*(zento(ji)+zdrago(ji))*dz2(ji,jk))
c         a_rho =   (drho/(1.-zexp)) / (zento(ji)+zdrago(ji))
c         b_rho = - (drho/(1.-zexp))
c    *            / (2.*(zento(ji)+zdrago(ji))-zento(ji))
c         zws2(ji) = a_rho*(1.-zexp2) + 2.*b_rho*(zexp-zexp2)

          zw2(ji) = sqrt ( max(zws2(ji),0.) )

c            If vertical velocity = 0, no new plume;
c            else, re-compute zu2 and zv2 for (non-linear) form drag

          if (zw2(ji).eq.0.) then
            zh2(ji) = 0.
            zq2(ji) = 0.
            zu2(ji) = 0.
            zv2(ji) = 0.
            zt2(ji) = 0.
            zrho2(ji) = 0.
            zprec2(ji) = 0.
            zlath2(ji) = 0.
            zws2(ji) = 0.
          else
            zenu = zento(ji) + zdrago(ji)*abs(0.5*(zu2(ji)))
     *                        / (0.5*zw2(ji))
            zenv = zento(ji) + zdrago(ji)*abs(0.5*(zv2(ji)))
     *                        / (0.5*zw2(ji))
            zexu  = exp(-zenu*dz2(ji,jk))
            zexv  = exp(-zenv*dz2(ji,jk))
            zu2(ji) = -(dudz(ji,jk)/zenu)*(1.-zexu)
            zv2(ji) = -(dvdz(ji,jk)/zenv)*(1.-zexv)
            zprec2(ji) = zareo(ji)*zrho2(ji)*zw2(ji)*delqn
          endif

  230   continue

c          In same way, integrate new-plume tracers from mid-point

        do 2300 n=1,ntrace
          do 2302 ji=1,nlon
            if (zw2(ji).gt.0.) then
              zexp = exp(-zento(ji)*dz2(ji,jk))
              za2(ji,n) = -(dadz2(ji,jk,n)/zento(ji))*(1.-zexp)
            else
              za2(ji,n) = 0.
            endif
 2302     continue
 2300   continue

c          Merge new plume into main plume. If no new plume, just
c          maintain the same main-plume radius.

        do 235 ji=1,nlon

          if (zw2(ji).gt.0.) then

            zprecnew = zprec(ji,jk) + zprec2(ji)
            zlath(ji,jk) = (  zprec(ji,jk)*zlath(ji,jk)
     *                      + zprec2(ji)  *zlath2(ji)   )
     *                   / max (zprecnew, 1.e-20)
            zprec(ji,jk) = zprecnew

            zaold(ji) = zarea(ji,jk)
            zwold(ji) = zw(ji,jk)
            zanew(ji) = zaold(ji) + zareo(ji)
            zwnew(ji) = (zaold(ji)*zwold(ji)+zareo(ji)*zw2(ji)) 
     *                / zanew(ji)

            zh(ji,jk) =
     *        (zaold(ji)*zwold(ji)*zh(ji,jk)+ zareo(ji)*zw2(ji)*zh2(ji))
     *        / (zanew(ji)*zwnew(ji))
            zq(ji,jk) =
     *        (zaold(ji)*zwold(ji)*zq(ji,jk)+ zareo(ji)*zw2(ji)*zq2(ji))
     *        / (zanew(ji)*zwnew(ji))
            zu(ji,jk) =
     *        (zaold(ji)*zwold(ji)*zu(ji,jk)+ zareo(ji)*zw2(ji)*zu2(ji))
     *        / (zanew(ji)*zwnew(ji))
            zv(ji,jk) =
     *        (zaold(ji)*zwold(ji)*zv(ji,jk)+ zareo(ji)*zw2(ji)*zv2(ji))
     *        / (zanew(ji)*zwnew(ji))

            zw(ji,jk) = zwnew(ji)
            zarea(ji,jk) = zanew(ji)
            zrad(ji,jk) = (zaold(ji)*zrad(ji,jkp)+zareo(ji)*zrado(ji)) 
     *                    / zanew(ji)

            zws(ji,jk) = zw(ji,jk)**2
            zt(ji,jk) = zh(ji,jk)*yplcap(ji,jj,jk)
            zrho(ji,jk) = ypl(ji,jj,jk)
     *                  / ( rair*(1.+zvir*(zq(ji,jk)+yqint(ji,jk)))
     *                     *(zh(ji,jk)+yhint(ji,jk))*yplcap(ji,jj,jk) )
          else

            zrad(ji,jk) = zrad(ji,jkp)

          endif

  235   continue

c          In same way, merge new-plume tracers into main plume

        do 2350 n=1,ntrace
          do 2352 ji=1,nlon
            if (zw2(ji).gt.0.) then
              za(ji,jk,n) = (  zaold(ji)*zwold(ji)*za(ji,jk,n)
     *                       + zareo(ji)*zw2(ji)*za2(ji,n) )
     *                    / (zanew(ji)*zwnew(ji))
            endif
 2352     continue
 2350   continue

c       Arbitrarily limit zw and/or zarea to satisfy "cfl" condition:
c       do 250 ji=1,nlon
c         if (zw(ji,jk).gt.0.) then
c           zarea*zw*timestep <= 0.5 * each adjacent layer thickness:
c           zw(ji,jk) = min (zw(ji,jk), 15.)
c           zws(ji,jk) = zw(ji,jk)**2
c           zarea(ji,jk) = min ( zarea(ji,jk), 
c    *                           0.5*min(dztot(ji,jk),dztot(ji,jk-1))
c    *                           / (zw(ji,jk)*twodt) )
c         endif
c 250   continue

c-------------
  200 continue
c-------------

c        Compute large-scale fluxes at layer boundaries. 

      do 300 jk=1,nlevp
        do 302 ji=1,nlon
          if (jk.eq.nlevp) then
            tplu(ji,jk) = ytflx(ji,jj)
            qplu(ji,jk) = yqflx(ji,jj)
            uplu(ji,jk) = yuflx(ji,jj)
            vplu(ji,jk) = yvflx(ji,jj)
          else
            zmass = zarea(ji,jk)*zrho(ji,jk)*zw(ji,jk)
            tplu(ji,jk) = zt(ji,jk)*zmass*cpair
            qplu(ji,jk) = zq(ji,jk)*zmass
            uplu(ji,jk) = zu(ji,jk)*zmass
            vplu(ji,jk) = zv(ji,jk)*zmass
          endif
  302   continue

        do 3020 n=1,ntrace
          do 3022 ji=1,nlon
            if (jk.eq.nlevp) then
              aplu(ji,jk,n) = 0.
            else
              zmass = zarea(ji,jk)*zrho(ji,jk)*zw(ji,jk)
              aplu(ji,jk,n) = za(ji,jk,n)*zmass
            endif
 3022     continue
 3020   continue

  300 continue

c        Compute flux convergence into each layer and add to reservoirs
c        fplum* ("flux*time per layer", in commun) for use in vdif.
c        Use dtime, not twodt, since reservoirs are not leapfrog 
c        variables (see comments in reserv).
 
      do 320 jk=1,nlev
        do 322 ji=1,nlon
          fplumt(ji,jj,jk) = fplumt(ji,jj,jk)
     *                     + (  tplu(ji,jk+1)-tplu(ji,jk)
     *                        + zprec(ji,jk)*zlath(ji,jk) ) * dtime
          fplumq(ji,jj,jk) = fplumq(ji,jj,jk)
     *                     + (  qplu(ji,jk+1)-qplu(ji,jk)
     *                        - zprec(ji,jk)              ) * dtime
          fplumu(ji,jj,jk) = fplumu(ji,jj,jk)
     *                     + (  uplu(ji,jk+1)-uplu(ji,jk) ) * dtime
          fplumv(ji,jj,jk) = fplumv(ji,jj,jk)
     *                     + (  vplu(ji,jk+1)-vplu(ji,jk) ) * dtime

          zqtot = zqtot
     *          + (qplu(ji,jk+1)-qplu(ji,jk))*twodt*cosbud(jj)/nlon
          zptot = zptot + zprec(ji,jk)*twodt*cosbud(jj)/nlon
          if (jk.eq.nlev) zetot = zetot 
     *                          + yqflx(ji,jj)*twodt*cosbud(jj)/nlon
  322   continue

        do 3220 n=1,ntrace
          do 3222 ji=1,nlon
            fplumtra(ji,jj,jk,n) = fplumtra(ji,jj,jk,n)
     *                     + (  aplu(ji,jk+1,n)-aplu(ji,jk,n) ) * dtime
 3222     continue
 3220   continue
  320 continue


c        Accumulate convective condensation rate (Kg/m2/s), and 
c        budget convective latent heating (dhcdcu, J/m2).

      do 330 jk=1,nlev
        do 332 ji=1,nlon
          convpra(ji,jj,jk) = convpra(ji,jj,jk) + zprec(ji,jk)

          dhcdcu = dhcdcu + zprec(ji,jk)*zlath(ji,jk)*dtime
     *                      *cosbud(jj)/nlon
  332   continue
  330 continue

c        Set history pbl heights for 03:00h and 15:00h, and accumulate
c        diagnostic number of pbl-tops (numpbl) or plume-tops (numplu)
c        in each layer

      if (nstep.eq.nrstrt) then
        call scopy (nlon, heipbl, 1, heip03(1,jj), 1)
        call scopy (nlon, heipbl, 1, heip15(1,jj), 1)
      endif
      heip03(ji03,jj) = heipbl(ji03)
      heip15(ji15,jj) = heipbl(ji15)

      do 420 ji=1,nlon
        numpbl(laypbl(ji)) = numpbl(laypbl(ji)) + 1
        numplu(layplu(ji)) = numplu(layplu(ji)) + 1
  420 continue

c        Diagnostic printout: zonal mean plume w's

ccur  call plumdiag (zw,jj,nstep,nrstrt,nstop,istepy,dtime,nout)   !ccur

c        Diagnostic printout: vertical profile at one point

ccur  iuprinz(1) = nout                                            !ccur
      iuprinz(1) = 6                                               !cloc
      iuprinz(2) = iuout                                           !cloc

ccur  nz = nint(86400./dtime)                                      !ccur
ccur  if (nstep.gt.nstop-nz .and. jj.eq.norec/2) then              !ccur
ccur    zzmax = -1.e20                                             !ccur
ccur    do 8000 ji=1,nlon                                          !ccur
ccur      zz = 0.                                                  !ccur
ccur      do 8002 jk=1,nlev                                        !ccur
ccur        if (zprec(ji,jk).gt.0.) zz = zz + 1.                   !ccur
c8002     continue                                                 !ccur
ccur      if (zz.gt.zzmax) then                                    !ccur
ccur        jim =ji                                                !ccur
ccur        zzmax = zz                                             !ccur
ccur      endif                                                    !ccur
c8000   continue                                                   !ccur
        jim = 1                                                    !cloc
        do 8010 ipz=1,nprinz
ccur      write(iuprinz(ipz),8012) nstep*dtime/86400., jim, jj     !ccur
c8012     format(' day=',f8.3,'  ji=',i3,'   jj=',i3)              !ccur
          write(iuprinz(ipz),8014) 
     *     (jk, sigkmh(jk),zarea(jim,jk), zw(jim,jk),
     *          zt(jim,jk), zq(jim,jk), zrho(jim,jk),
     *          yhint(jim,jk), yqint(jim,jk),yrhoint(jim,jk),
     *          tplu(jim,jk), qplu(jim,jk)*.864e5,
     *          yq(ji,jim,min(jk,nlev)), zprec(jim,min(jk,nlev))*.864e5,
     *      jk=nlevp,1,-1)
 8014     format(' jk',4x,'sig',5x,'zarea',8x,'zw',
     *                  8x,'zt',8x,'zq',6x,'zrho',
     *                  5x,'yhint',5x,'yqint',3x,'yrhoint',
     *                  6x,'tplu',6x,'qplu',
     *                  6x,'newq',5x,'zprec'
     *           /(i3,f7.3,12f10.5))
 8010   continue
ccur  endif                                                        !ccur

c        Diagnostic printout: one line for one point

ccur  nz = nint(86400./dtime)                                      !ccur
ccur  if (nstep.gt.nstop-2*nz .and. nstep.le.nstop-nz              !ccur
ccur *    .and.jj.eq.norec/2) then                                 !ccur
        ji = max (1, nlon/2)
ccur    if (mod(nstep,nz).eq.1) write(iuout,8020) ji,jj            !ccur
 8020   format(/' ji,jj=',2i3)                                     

        do 8022 jk=1,nlev
          chaplu(jk) = '   '
 8022   continue
        chaplu(layplu(ji)) = '***'

        do 8030 ipz=1,nprinz
          write(iuprinz(ipz),8032)
 8032     format(5x,'day',2x,'heipbl',3x,'ytflx',
     *           5x,5(6x,'yh',1x),5x,5(6x,'yq',1x) )
          write(iuprinz(ipz),8034) nstep*dtime/86400., 
     *      heipbl(ji), ytflx(ji,jj),
     *      (yt(ji,jj,jk)/ypmcap(ji,jj,jk),chaplu(jk)(1:1), 
     *      jk=nlev,nlev-4,-1),
     *      (yq(ji,jj,jk),chaplu(jk)(1:1), jk=nlev,nlev-4,-1)
 8034     format(f8.3,f8.1,f8.1,5x,5(f8.2,a1),5x,5(f8.5,a1))
 8030   continue
ccur  endif                                                        !ccur

c        End of overall loop over latitude

c=============
 1000 continue
c=============

c        Save 03:00h and 15:00h history pbl heights

      call puthis (heip03, 63)
      call puthis (heip15, 64)
      
c        Diagnostic printout: number of negative q's globally vs level

      zz = twodt / (2.*3600.)
      qnegmax = 1.e20
      nqnegtot = 0
      do 8040 jk=1,nlev
        qrat(jk) = 0.
        qneg(jk) = 0.
        nqrat(jk) = 0
        nqneg(jk) = 0
        do 8042 jj=1,norec
        do 8042 ji=1,nlon
          dqnew = zz * fplumq(ji,jj,jk) / (ypthic(ji,jj,jk)/gravit)
          if (abs(yq(ji,jj,jk)).gt.0.00005) then
            qrat(jk) = qrat(jk) + abs(dqnew) / abs(yq(ji,jj,jk))
            nqrat(jk) = nqrat(jk) + 1
          endif
          qnew = yq(ji,jj,jk) + dqnew
          if (qnew.lt.0.) then
            qneg(jk) = qneg(jk) + qnew
            nqneg(jk) = nqneg(jk) + 1
            nqnegtot = nqnegtot + 1
            if (qnew.lt.qnegmax) then
              qnegmax = qnew
              jkmax = jk
              jimax = ji
              jjmax = jj
            endif
          endif
 8042   continue
        if (nqrat(jk).gt.0) qrat(jk) = qrat(jk)/nqrat(jk)
        if( nqneg(jk).gt.0) qneg(jk) = qneg(jk)/nqneg(jk)
 8040 continue

      if (nqnegtot.gt.0) then
        do 8050 ipz=1,nprinz
          write(iuprinz(ipz),8052)
     *       nstep*dtime/86400., zptot, zetot, zqtot,
     *       qnegmax, jimax,jjmax,jkmax,
     *       nqrat(jkmax),qrat(jkmax),nqneg(jkmax),qneg(jkmax)
 8052     format(/' day=',f8.3,
     *            '   zptot=',f10.5,'   zetot=',f10.5,'   zqtot=',f10.5
     *           /' qnegmax=',f10.5,'  at=',3i4
     *           /' nqrat=',i4,'   qrat=',f9.6,'  nqneg=',i4,
     *            '  qneg=',f9.6)
 8050   continue
      endif

c        Diagnostic printout: max heip15, numplu

c     nz = nint(86400./dtime)
c     if (nstep.gt.nstop-nz) then
c       zz = -1.e20
c       do 8060 jj=1,norec
c       do 8060 ji=1,nlon
c         if (heip15(ji,jj).gt.zz) then
c           izz = ji
c           jzz = jj
c           zz = heip15(ji,jj)
c         endif
c8060   continue
c       write(*,8062) nstep*dtime/86400., zz, izz, jzz,
c    *                (numplu(jk),jk=nlev,1,-1) 
c8062   format(' day=',f8.3,'  heip15=',f8.1,'  at ji,jj=',2i3,
c    *         '  numplu=',(18i5))
c     endif
      
c        Diagnostic printout: number of pbl and plume tops in each layer
c        written to fort.87 

c     if ( mod(nstep,nint(1.*86400./dtime)) .eq. 0 ) then
c       iu = 87
c       write(iu,*)
c       write(iu,8070)nstep*dtime/86400.,'pbl',(numpbl(jk),jk=nlev,1,-1)
c       write(iu,8070)nstep*dtime/86400.,'plu',(numplu(jk),jk=nlev,1,-1)
c8070   format(' plume: time=',f9.3,' num',a,'=',(18i5))
c       ier = flush (iu)                                        
c     endif

      return
      end
c
c ***************************** reevap *********************************
c
      subroutine reevap (yt, yq, ypm, ypthic, precipa, 
     *                   fplumt, fplumq, frain, fsnow, 
     *                   dhcd, icode)

c     Does re-evaporation of falling precipitation. Called separately
c     for convective and stratiform precip, to allow (i) diagnostics,
c     (ii) different reevap fractions of originating precip (see below),
c     and (iii) different stochastic params in lsx for conv vs strat.
c     As precip enters a layer from above, its sensible heat and phase
c     are adjusted to that layer's temperature and the associated heat
c     flux given to fplumt for that layer. Then a fraction of the precip
c     re-evaporates or sublimates within that layer proportional to the
c     ambient dryness (qsat-q), using a conceptual model with fixed
c     fall velocities, transfer coeffs and drop radii. Another fraction
c     is used for reevap of precip *originating* in that layer. This
c     is larger than for falling precip to crudely represent in-situ
c     clouds...here we are anticipating the in-situ re-evaporation
c     of non-precipitating clouds. This in-situ fraction can be 
c     different for stratiform and convective clouds; for simplicity its
c     functional dependence on ambient dryness and layer thickness is
c     the same as for falling precip.

c     Supplied:
c     yt      = agcm temperatures (deg K)
c     yq      = agcm specific humidity (kg/kg)
c     ypm     = agcm mid-layer pressure (N/m2)
c     ypthic  = agcm layer pressure thicknesses (N/m2)
c     precipa = 3-D precip formation rate (strat or conv) (kg/m2/s)
c     icode   = 0 for stratiform, 1 for convective

c     Modified (incremented):
c     fplum* = reservoirs of "flux convergence*time" in each agcm layer
c              (J/m2 for fplumt, kg/m2 for fplumq)
c     frain  = rainfall rate at ground (kg/m2/s)
c     fsnow  = snowfall rate at ground (kg/m2/s)
c     dhcd   = global re-evap heating budget (dhcdcur or dhcdstr) (J/m2)

c ---------------------------------------------------------------------
      include 'complume'                                          !cloc
c ---------------------------------------------------------------------
      dimension 
     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  ypm(plon,porec,plev),     ypthic(plon,porec,plev),
     *  precipa(plon,porec,plev), 

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  frain(plon,porec),        fsnow(plon,porec)

      dimension
     *  zdqsat(plon),  zrho(plon),    zdz(plon),
     *  zfacp(plon),   zfaco(plon),   zlath(plon),   zch(plon),
     *  zprec(plon),   zdprec(plon),  zcoolp(plon),
     *  zorig(plon),   zdorig(plon),  zcoolo(plon),
     *  za(plon),      zb(plon)
c ---------------------------------------------------------------------
c  zevp    is a factor in the re-evap fraction of falling precip,
c  zevo_st is the same for originating stratiform precip,
c  zevo_cu is the same for originating convective precip.
c     parameter (zevp=0.0, zevo_st=0.0, zevo_cu=0.0) ! *** Turn off ***
c     parameter (zevp=0.4, zevo_st=0.4, zevo_cu=2.0)
c     parameter (zevp=0.2, zevo_st=0.2, zevo_cu=0.2)
c     parameter (zevp=0.1, zevo_st=0.1, zevo_cu=0.1)
c002  parameter (zevp=.02, zevo_st=.02, zevo_cu=.02)
c003  parameter (zevp=.05, zevo_st=.05, zevo_cu=.05)
ccur  parameter (zevp=.05, zevo_st=.05, zevo_cu=.05)               !ccur
      parameter (zevp=.05, zevo_st=.05, zevo_cu=.05)               !cloc
c-----------------------------------------------------------------------
      include 'comsatplume'                                        !cloc
c-----------------------------------------------------------------------

c     Initialize diagnostics: global precip formation (zdiagpa) 
c     and precip reaching ground (zdiagpg)

      zdiagpa = 0.
      zdiagpg = 0.

c     Outer loop over latitude

c=====
      do 1000 jj=1,norec
c=====

c       Algorithm does one pass from top to bottom layer, one longitude
c       strip at a time.
c         zprec = falling precip (kg/m2/s)
c         zorig = precip originating in current layer (kg/m2/s)

        call zero (zprec,nlon)

c=====
        do 100 jk=1,nlev
c=====

          call scopy (nlon, precipa(1,jj,jk), 1, zorig, 1)

          zprecsum = ssum(nlon,zprec,1)
          zorigsum = ssum(nlon,zorig,1)

c         If no precip entering layer from above and no originating
c         precip (for any longitude), don't do anything. Else set up:
c           zlath = sensible+latent heat for reevap within layer
c                   (as if all phase changes occur at tmelt as in LSX)
c           zfacp = fraction of falling precip reevaped in this  layer
c           zfaco = fraction of originating precip reevaped within layer

c-----
          if (zprecsum.ne.0. or. zorigsum.ne.0.) then
c-----
            do 110 ji=1,nlon
              zlath(ji) = cvmgt ( latvap + cpwv*(yt(ji,jj,jk)-tmelt)
     *                                   - ch2o*(yt(ji,jj,jk)-tmelt),
     *                            latsub + cpwv*(yt(ji,jj,jk)-tmelt)
     *                                   - cice*(yt(ji,jj,jk)-tmelt),
     *                            yt(ji,jj,jk).ge.tmelt )
              zdqsat(ji) = qstblf (yt(ji,jj,jk), ypm(ji,jj,jk))
     *                   - yq(ji,jj,jk)
              zrho(ji) = ypm(ji,jj,jk)
     *                 / (rair*(1.+zvir*yq(ji,jj,jk))*yt(ji,jj,jk))
              zdz(ji) = ypthic(ji,jj,jk) / (gravit*zrho(ji))
              zz = zevp * zdz(ji) * max(zdqsat(ji),0.)
              zfacp(ji) = 1.-exp(-zz)
  110       continue

            if (icode.eq.0) then
              do 114 ji=1,nlon
                zz = zevo_st * zdz(ji) *  max(zdqsat(ji),0.)
                zfaco(ji)= 1.-exp(-0.5*zz)
c               zfaco(ji) = cvmgt ( 1.-(1.-exp(-zz))/max(zz,1.e-10),
c    *                              0., zz.gt.1.e-10 )
  114         continue
            else
              do 116 ji=1,nlon
                zz = zevo_cu * zdz(ji) *  max(zdqsat(ji),0.)
                zfaco(ji)= 1.-exp(-0.5*zz)
  116         continue
            endif

c           Fudge to make reevap happen more in lower layers
c           zfud = max (0., min (1., (sig(jk)-.7)/.3 ))
c           do 118 ji=1,nlon
c             zfacp(ji) = zfacp(ji) * zfud
c             zfaco(ji) = zfaco(ji) * zfud
c 118       continue

c-----
          endif
c-----

c         If any precip entering from above, (i) adjust it to the
c         ambient layer temperature and (ii) re-evaporate fraction
c         zfacp. Give associated heat and vapor fluxes from both
c         processes to the large-scale reservoirs fplum[t,q], and
c         increment budget diagnostic dhcd. First set:
c           zch = sensible+latent heat for adjust to layer temperature
c                 (as if all phase changes occur at tmelt as in LSX)

c-----
          if (zprecsum.ne.0.) then
c-----
            jkm = jk - 1
            do 120 ji=1,nlon
              za(ji) = cvmgt (0.5, -0.5, yt(ji,jj,jkm).ge.tmelt)
              zb(ji) = cvmgt (0.5, -0.5, yt(ji,jj,jk) .ge.tmelt)
              zch(ji) = - cvmgt ( ch2o, cice, yt(ji,jj,jkm).ge.tmelt )
     *                          * (yt(ji,jj,jkm)-tmelt)
     *                  + cvmgt ( ch2o, cice, yt(ji,jj,jk) .ge.tmelt )
     *                          * (yt(ji,jj,jk)-tmelt)
     *                  + latice* (zb(ji)-za(ji))

              zdprec(ji) = zprec(ji)*zfacp(ji)
              zcoolp(ji) = zprec(ji)*zch(ji) + zdprec(ji)*zlath(ji)
              fplumq(ji,jj,jk) = fplumq(ji,jj,jk) + zdprec(ji)*dtime
              fplumt(ji,jj,jk) = fplumt(ji,jj,jk) - zcoolp(ji)*dtime
              zprec(ji) = zprec(ji) - zdprec(ji)
  120       continue

            dhcd = dhcd - (ssum(nlon,zcoolp,1)/nlon)*cosbud(jj)*dtime
c-----
          endif
c-----

c         If any precip originating in this layer, re-evaporate
c         fraction zfaco and add the remainder to zprec. Give associated
c         heat and vapor fluxes to the large-scale reservoirs fplum[t,q]
c         and increment budget diagnostic dhcd.

c-----
          if (zorigsum.ne.0.) then
c-----
            do 130 ji=1,nlon
              zdorig(ji) = zorig(ji)*zfaco(ji)
              zcoolo(ji) = zdorig(ji)*zlath(ji)
              fplumq(ji,jj,jk) = fplumq(ji,jj,jk) + zdorig(ji)*dtime
              fplumt(ji,jj,jk) = fplumt(ji,jj,jk) - zcoolo(ji)*dtime
              zorig(ji) = zorig(ji) - zdorig(ji)
  130       continue

            dhcd = dhcd - (ssum(nlon,zcoolo,1)/nlon)*cosbud(jj)*dtime

            do 140 ji=1,nlon
              zprec(ji) = zprec(ji) + zorig(ji)
  140       continue
c-----
          endif
c-----

c         Increment diagnostic global precip formation rate

          zdiagpa = zdiagpa + (zorigsum/nlon)*cosbud(jj)

c=====
  100   continue
c=====

c       At this point zprec = precip falling out of bottom of lowest
c       layer, with temperature of lowest layer and phase depending
c       on that temp >= or < tmelt. Increment model precip quantities
c       (frain,fsnow) and diagnostic zdiagpg.

        do 200 ji=1,nlon
          frain(ji,jj) = cvmgt ( frain(ji,jj)+zprec(ji), frain(ji,jj),
     *                           yt(ji,jj,nlev).ge.tmelt )
          fsnow(ji,jj) = cvmgt ( fsnow(ji,jj)+zprec(ji), fsnow(ji,jj),
     *                           yt(ji,jj,nlev).lt.tmelt )
  200   continue

        zdiagpg = zdiagpg + (ssum(nlon,zprec,1)/nlon)*cosbud(jj)

c=====
 1000 continue
c=====

      if ( mod(nstep,nint(.5*86400./dtime)) .eq. 0 ) then
        if (icode.eq.0) write(*,*)
        zz = 8.64e7/rhoh2o
        write(*,900) nstep*dtime/86400., icode,
     *    zz*zdiagpa, zz*zdiagpg, zdiagpg/max(zdiagpa,1.e-10)
  900   format(' reevap:  day=',f9.3,'  icode=',i2,'  condens=',f8.3,
     *         '  precip=',f8.3,'  p/c=',f6.3)
      endif

      data ztot /0./
      ztot = ztot + (8.64e7/rhoh2o)*zdiagpg
      if (mod(nstep,nint(1.*86400./dtime)) .eq. 0 .and.icode.eq.1) then
        write(*,902) nstep*dtime/86400., ztot/nint(1.*86400./dtime)
  902   format(/' reevap: day=',f9.3,'  daily mean precip = ',f8.3)
        ztot = 0.
      endif

      return
      end
c
c **************************** vinterp *********************************
c
      subroutine vinterp (a, sig, aprof, sigprof, nlon,norec,nlev,nprof)

c     Vertically interpolates basic state a(nlev) from aprof(nprof)

      dimension a(nlon,norec,nlev),sig(nlev),aprof(nprof),sigprof(nprof)

      do 100 jk=1,nlev

        if (sig(jk).le.sigprof(1)) then
          jkpa = 1
          jkpb = 1
          weia = 1.
        else if (sig(jk).ge.sigprof(nprof)) then
          jkpa = nprof
          jkpb = nprof
          weia = 1.
        else
          do 10 jkp=2,nprof
            if (sig(jk).le.sigprof(jkp)) then
              jkpa= jkp-1
              jkpb= jkp
              weia= (sigprof(jkp)-sig(jk))/(sigprof(jkp)-sigprof(jkp-1))
              goto 12
            endif
   10     continue
        endif
   12   continue

        do 20 jj=1,norec
          do 22 ji=1,nlon
            a(ji,jj,jk) = weia*aprof(jkpa) + (1.-weia)*aprof(jkpb)
   22     continue
   20   continue

  100 continue

      return
      end
c
c **********************************************************************
c
      subroutine zero (arr, nar)
c
c        zeros nar words starting at arr(1)
c
      dimension arr(nar)
      do 10 j=1,nar
        arr(j) = 0.
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine reseti (iarr, nar, ival)
c
c        sets nar integer words to ival starting at iarr(1)
c
      dimension iarr(nar)
      do 10 j=1,nar
        iarr(j) = ival
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine puthis (arr, icode)
c
c        dummy write to history file
c
      dimension arr(1,1)
      return
      end
c
c **********************************************************************
c
      function cvmgt (vala, valb, test)
      logical test

      if (test) then
        cvmgt = vala
      else
        cvmgt = valb
      endif
      return
      end
c
c **********************************************************************
c
      function ssum (n, arr, inc)
      dimension arr(n)

      ssum = 0.
      do 10 i=1,n,inc
        ssum = ssum + arr(i)
   10 continue
      return
      end
c
c **********************************************************************
c
      function sigma (n, arr, inc)
      dimension arr(n)

      ssum = 0.
      do 10 i=1,n,inc
        ssum = ssum + arr(i)
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine scopy (n, arr, inca, brr, incb)
      dimension arr(n), brr(n)

      j = 1
      do 10 i=1,n,inca
        brr(j) = arr(i)
        j = j + incb
   10 continue
      return
      end
