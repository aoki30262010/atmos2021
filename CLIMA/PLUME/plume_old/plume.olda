c
c **********************************************************************
c
      program doplume

c ---------------------------------------------------------------------
      include 'complume'
c ---------------------------------------------------------------------
      dimension 
     *  ytflx(plon,porec),        yqflx(plon,porec),
     *  yuflx(plon,porec),        yvflx(plon,porec),

     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  yu(plon,porec,plev),      yv(plon,porec,plev), 
     *  yps(plon,porec),          
     *  tracer(plon,porec,plev,ptrace),

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  fplumu(plon,porec,plev),  fplumv(plon,porec,plev),
     *  fplumtra(plon,porec,plev,ptrace),

     *  qct2(plon,porec,plev),  
     *  convpra(plon,porec,plev), convpr(plon,porec),
     *  strapra(plon,porec,plev), strapr(plon,porec),
     *  frain(plon,porec),        fsnow(plon,porec)

      data iuout /10/

      dimension sigprof(nprof)
      data sigprof /
     *  .009, .025, .060, .110, .165, .245, 
     *  .355, .500, .664, .811, .926, .991 /
      dimension tprof(nprof), qprof(nprof)
      data tprof /
     *   230, 223, 208, 192, 204, 225, 248, 267, 282, 288, 294, 298/
      data qprof /
     *     0,   0,   0,   0,   0, 0.1, 0.4, 1.0, 3.2, 9.5,14.5,14.0/
c    *     0,   0,   0,   0,   0,  .1,  .5,   1,   3,  10,  14,  15/

      dimension sig12(12), sig16(16)
      data sig12 /
     *  .009, .025, .060, .110, .165, .245, 
     *  .355, .500, .664, .811, .926, .991 /
      data sig16 /
     *  .010, .030, .060, .110, .175, .255, .350, .450, 
     *  .550, .650, .745, .830, .900, .950, .980, .995 /

c ---------------------------------------------------------------------
      include 'comsatplume'
c ---------------------------------------------------------------------

      nlon = plon
      norec = porec
      nlev = plev
      ntrace = ptrace

      dtime = 1800.
      twodt = 2.*dtime
      nstep = 1
      nrstrt = 1
      nstop = 10

      cpair  = 1004.64
      gravit = 9.80616
      latvap = 2.5104e06
      latice = 3.336e5
      latsub = latvap + latice
      rair   = 287.04
      rh2o   = 4.61e2
      rhoh2o = 1.e3
      ch2o = 4.218e3
      cice = 2.106e3
      tmelt  = 273.16
      cappa  = rair/cpair
      zvir   = rh2o/rair -1.
      cpwv   = 1.81e3
      cpvir  = cpwv/cpair - 1.

      dtbud = dtime
      facbud = 1.

      do 1 ji=1,nlon
        along(ji) = ((ji-.5)/nlon) * 2. * 3.1415927
    1 continue

      do 2 jj=1,norec
        cosbud(jj) = 0.5/norec
    2 continue

      do 3 jk=1,nlev
        if (nlev.eq.12) then
          sig(jk) = sig12(jk)
        else if (nlev.eq.16) then
          sig(jk) = sig16(jk)
        else
          sig(jk) = (jk-0.5)/nlev
        endif
    3 continue

      do 4 jk=2,nlev
        sigkmh(jk) = 0.5*(sig(jk-1)+sig(jk))
    4 continue
      sigkmh(1) = 0.
      sigkmh(nlev+1) = 1.

      sigipk(1) = 0.
      do 5 jk=1,nlev
        sigkpk(jk) = sig(jk)**cappa
        sigipk(jk+1) = sigkmh(jk+1)**cappa
        dsigma(jk) = sigkmh(jk+1) - sigkmh(jk)
    5 continue
      sigkpk(nlev+1) = 1.

c     do 6 jkp=1,nprof
c       tprof(jkp) = 300.*(sigprof(jkp)**cappa)
c       qprof(jkp) = 1000. * 0.5*qstblf(tprof(jkp),sigprof(jkp)*1.e5)
c   6 continue

      call vinterp (yt, sig, tprof, sigprof, nlon,norec,nlev,nprof)
      call vinterp (yq, sig, qprof, sigprof, nlon,norec,nlev,nprof)

      do 10 jk=1,nlev
        do 12 jj=1,norec
          do 14 ji=1,nlon
            yq(ji,jj,jk) = .001 * yq(ji,jj,jk)
            yu(ji,jj,jk) = 5.
            yv(ji,jj,jk) = 5.
   14     continue
   12   continue
   10 continue

c------------------------
      do 1000 iloop=1,100
c------------------------

  500 write(*,501)
      read(*,502,err=500) xytflx, xyqflx, xzent, xdopbl, xdofree
      if (xzent.eq.0.) xzent = .1/200.
      if (xzent.lt.0.) xzent = 0.
      if (xdopbl .lt.-1. .or. xdofree.lt.-1.) stop
      if (xdopbl .ge.0.) xdopbl  = 1.
      if (xdofree.gt.0.) xdofree = 1.
      write(*,503)    xytflx, xyqflx, xzent, nint(xdopbl), nint(xdofree)
      write(iuout,501)
      write(iuout,503)xytflx, xyqflx, xzent, nint(xdopbl), nint(xdofree)
  501 format(/1x,33('-')/
     * ' ytflx  yqflx   zent  dopbl dofree')
  502 format(
     *    f6.0,  f7.0,  f7.0,  f7.0   f7.0)
  503 format(
     *    f6.1,  f7.1,2x,f5.4,   i7,    i7)

      do 16 jj=1,norec
        do 18 ji=1,nlon
          yps(ji,jj) = 1.e5
          ytflx(ji,jj) = xytflx
          yqflx(ji,jj) = xyqflx/86400.
          yuflx(ji,jj) = .1
          yvflx(ji,jj) = .1
   18   continue
   16 continue

      dhcdst  = 0.
      dhcdcu  = 0.
      dhcdstr = 0.
      dhcdcur = 0.

      call zero (tracer,   nlon*norec*nlev*ntrace)
      call zero (fplumt,   nlon*norec*nlev)
      call zero (fplumq,   nlon*norec*nlev)
      call zero (fplumu,   nlon*norec*nlev)
      call zero (fplumv,   nlon*norec*nlev)
      call zero (fplumtra, nlon*norec*nlev*ntrace)
      call zero (qct2,     nlon*norec*nlev)
      call zero (convpra,  nlon*norec*nlev)
      call zero (convpr,   nlon*norec)
      call zero (strapra,  nlon*norec*nlev)
      call zero (strapr,   nlon*norec)
      call zero (frain,    nlon*norec)
      call zero (fsnow,    nlon*norec)
     
c        PBL (dry) plumes

      if (xdopbl.eq.1.) then

        call plume ( ytflx, yqflx, yuflx, yvflx, 
     *               yt, yq, yu, yv, yps, tracer, ntrace,
     *               fplumt, fplumq, fplumu, fplumv, fplumtra,
     *               qct2, convpra, 0 )

      endif


c        Free convection

      if (xdofree.eq.1.) then

c          Stable condensation
   
        call stabco (yt, yq, yps, qct2, strapra)
   
c          Dry/wet plume convection
   
        call plume ( ytflx, yqflx, yuflx, yvflx, 
     *               yt, yq, yu, yv, yps, tracer, ntrace,
     *               fplumt, fplumq, fplumu, fplumv, fplumtra,
     *               qct2, convpra, 1 )
   
c          Reevaporation of falling precip (separately for
c          stratiform and convective just for diagnostics)
   
        call reevap ( yt, yq, yps, strapra, 
     *                fplumt, fplumq, qct2, strapr, frain, fsnow, 
     *                dhcdstr, 0 )
   
        call reevap ( yt, yq, yps, convpra, 
     *                fplumt, fplumq, qct2, convpr, frain, fsnow, 
     *                dhcdcur, 1 )

      endif

c-------------
 1000 continue
c-------------

      stop
      end
c
c **************************** vinterp *********************************
c
      subroutine vinterp (a, sig, aprof, sigprof, nlon,norec,nlev,nprof)

c     Vertically interpolates basic state a(nlev) from aprof(nprof)

      dimension a(nlon,norec,nlev),sig(nlev),aprof(nprof),sigprof(nprof)

      do 100 jk=1,nlev

        if (sig(jk).le.sigprof(1)) then
          jkpa = 1
          jkpb = 1
          weia = 1.
        else if (sig(jk).ge.sigprof(nprof)) then
          jkpa = nprof
          jkpb = nprof
          weia = 1.
        else
          do 10 jkp=2,nprof
            if (sig(jk).le.sigprof(jkp)) then
              jkpa= jkp-1
              jkpb= jkp
              weia= (sigprof(jkp)-sig(jk))/(sigprof(jkp)-sigprof(jkp-1))
              goto 12
            endif
   10     continue
        endif
   12   continue

        do 20 jj=1,norec
          do 22 ji=1,nlon
            a(ji,jj,jk) = weia*aprof(jkpa) + (1.-weia)*aprof(jkpb)
   22     continue
   20   continue

  100 continue

      return
      end
c
c ***************************** stabco *********************************
c
      subroutine stabco (yt, yq, yps, qct2, strapra)

c     Does stable condensation, iterating niter times for each grid pt.

c     yt      = temperature field (modified)
c     yq      = specific humidity (modified)
c     yps     = surface pressure (supplied)
c     qct2    = 3-D net condensation heating rate (modified)
c     strapra = 3-D stable precip formation rate (modified)

c ---------------------------------------------------------------------
      include 'complume'
c ---------------------------------------------------------------------
      dimension 
     *  yt(plon,porec,plev),    yq(plon,porec,plev),
     *  yps(plon,porec),
     *  qct2(plon,porec,plev),  strapra(plon,porec,plev)

      dimension
     *  delq(plon), za(plon), zsum(plon),
     *  zsvp(plon), zsvq(plon), ztmp1(plon), ztmp2(plon)

      save niter
      data niter /2/
c ---------------------------------------------------------------------
      include 'comsatplume'
c ---------------------------------------------------------------------


      ztodt = twodt
      if (nstep.eq.0) ztodt = 0.5*twodt

c=====
      do 1000 iter=1,niter
      do 100 jj=1,norec
c=====
        do 200 jk=1,nlev

c         call estabv (zsvp, zsvq, yt(1,jj,jk), yps(1,jj), ztmp1, ztmp2,
c    *                 nlon, 1, sig(jk), 1.)
          do 250 ji=1,nlon
            zsvp(ji) = esat(yt(ji,jj,jk))
            zsvq(ji) = qsat(zsvp(ji), yps(ji,jk)*sig(jk))
  250     continue

          do 300 ji=1,nlon

c              za is latent heat of condensation, determined by ambient
c              temperature (ie, rain or snow), plus correction
c              for specific heats to be consistent with lsx (imagining
c              all phase changes occur at tmelt)

            za(ji) = cvmgt ( latvap + cpwv*(yt(ji,jj,jk)-tmelt)
     *                              - ch2o*(yt(ji,jj,jk)-tmelt),
     *                       latsub + cpwv*(yt(ji,jj,jk)-tmelt)
     *                              - cice*(yt(ji,jj,jk)-tmelt),
     *                       yt(ji,jj,jk).ge.tmelt )

c              Test for saturation, and condense amount that results 
c              in exactly saturated air. Store amount in delq.

            if (yq(ji,jj,jk).gt.zsvq(ji)) then
              dz = (za(ji)/rh2o) * zsvq(ji) / (yt(ji,jj,jk)**2)
              cpz = cpair*(1.+cpvir*yq(ji,jj,jk))
              delq(ji) = (yq(ji,jj,jk) - zsvq(ji)) / (1.+dz*za(ji)/cpz)
              yq(ji,jj,jk) = yq(ji,jj,jk) - delq(ji)
              yt(ji,jj,jk) = yt(ji,jj,jk) + delq(ji)*za(ji)
     *                                 / (cpair*(1.+cpvir*yq(ji,jj,jk)))
            else
              delq(ji) = 0.
            endif

c              Accumulate net condensation heating rate (qct2, W/m2)
c              and stratiform precip formation rate (Kg/m2/s)

            zz = delq(ji) * (dsigma(jk)*yps(ji,jj)/gravit) / ztodt
            qct2(ji,jj,jk) = qct2(ji,jj,jk) + zz*za(ji)
            strapra(ji,jj,jk) = strapra(ji,jj,jk) + zz

  300     continue

c            Budget calculation for net stable latent heating (J/m2)

          if (ntwo.eq.1) then
            do 320 ji=1,nlon
              zsum(ji)=  delq(ji)*za(ji)*(dsigma(jk)*yps(ji,jj)/gravit)
  320       continue
            zsumh = sigma(nlon,zsum,1)
            dhcdst = dhcdst + (zsumh/nlon)*cosbud(jj)*facbud
          endif

  200   continue
c=====
  100 continue
 1000 continue
c=====

      return
      end
c
c ***************************** plume ********************************
c
      subroutine plume ( ytflx, yqflx, yuflx, yvflx, 
     *                   yt, yq, yu, yv, yps, tracer, ntrace,
     *                   fplumt, fplumq, fplumu, fplumv, fplumtra,
     *                   qct2, convpra, icode)

c     Does convection, both for pbl (icode=0) and within atmos(icode=1),
c     by solving a subgrid plume model. For the pbl, one plume is 
c     tracked originating at the center of the lowest layer (ie, top of
c     constant-flux layer) with w,t values scaled depending on the
c     surface heat/momentum fluxes based on constant-flux scaling.
c     The plume stops when its w = 0. No condensation occurs in this
c     plume, since model time-step logic could not handle cloud/precip
c     generation by pbl calls (called after surfctl at start of vdiff).

c     For "within-atmos" or "c.a." calls, a plume originate at the 
c     center of a model layer if it can rise to (or beyond) the top of
c     that layer. This plume is then merged with an ongoing single main
c     plume if it exists, that is tracked from layer boundary to layer
c     boundary, forming a new single main plume incoming at the bottom
c     of the next layer. Condensation can occur in either of these 
c     plumes, forming precipitation. The procedure starts at the center
c     of the lowest model layer and tests for unstable plumes reaching
c     (beyond) the top of that layer. These calls are made from convad
c     after the main dynamical leapfrog timestep.

c     The plume equations explicitly solve for plume w,theta,q,u,v where
c     all except w are perturbations from the ambient quantities. The
c     plume vertical finite-difference step is upwards from layer
c     boundary to layer boundary. These quantities, along with the plume
c     condensation amounts, then imply the large-scale fluxes at layer
c     boundaries and the large-scale precip and latent heat release.
c     The large-scale flux convergences are actually put in reservoirs
c     fplum* and released (see reserv, called from vdiff) with a time 
c     scale of a few hours.

c     supplied:
c     ytflx   = upward sensible heat flux from surface (W/m2)
c     yqflx   = upward h2o mass flux from surface (Kg/m2/s)
c     yuflx   = upward u-momentum flux from surface (N/m2)
c     yvflx   = upward v-momentum flux from surface (N/m2)
c     yt      = agcm temperatures
c     yq      = agcm specific humidity
c     yu      = agcm eastward  velocity
c     yv      = agcm northward velocity 
c     yps     = agcm surface pressure 
c     tracer  = agcm tracer fields
c     ntrace  = number of agcm tracer fields

c     modified:
c     fplum*  = reservoirs of "flux convergence*time" in each agcm layer

c     modified for "c.a.":
c     qct2    = 3-D net condensation heating rate (modified)
c     convpra = 3-D convective precip formation rate (modified)

c     icode  = 0 for "pbl" calls, else for "c.a." calls

c ---------------------------------------------------------------------
      include 'complume'
c ---------------------------------------------------------------------
      dimension 
     *  ytflx(plon,porec),        yqflx(plon,porec),
     *  yuflx(plon,porec),        yvflx(plon,porec),

     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  yu(plon,porec,plev),      yv(plon,porec,plev), 
     *  yps(plon,porec),          
     *  tracer(plon,porec,plev,ptrace),

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  fplumu(plon,porec,plev),  fplumv(plon,porec,plev),
     *  fplumtra(plon,porec,plev,ptrace),

     *  qct2(plon,porec,plev),    convpra(plon,porec,plev)

      dimension
     *  yh(porec,plev),     yrho(porec,plev),

     *  yhint(porec,plevp), yqint(porec,plevp), 
     *  yuint(porec,plevp), yvint(porec,plevp), 
     *  yrhoint(porec,plevp),
     *  yaint(porec,plevp,ptrace),

     *  dz(porec,plev),     dztot(porec,plev),
     *  dhdz(porec,plev),   dqdz(porec,plev),
     *  dudz(porec,plev),   dvdz(porec,plev),
     *  dadz(porec,plev,ptrace),

     *  dz2(porec,plev),
     *  dhdz2(porec,plev),  dqdz2(porec,plev),
     *  dudz2(porec,plev),  dvdz2(porec,plev),
     *  dadz2(porec,plev,ptrace)

      dimension
     *  zh(porec,plevp),    zq(porec,plevp), 
     *  zu(porec,plevp),    zv(porec,plevp),    
     *  zw(porec,plevp),    zws(porec,plevp),
     *  zt(porec,plevp),    zrho(porec,plevp),
     *  za(porec,plevp,ptrace),

     *  zarea(porec,plevp),

     *  zh2(porec),         zq2(porec), 
     *  zu2(porec),         zv2(porec),    
     *  zw2(porec),         zws2(porec),
     *  zt2(porec),         zrho2(porec),
     *  zprec2(porec),      zlath2(porec),
     *  za2(porec,ptrace),

     *  zprec(porec,plev),  zlath(porec,plev),

     *  tplu(porec,plevp),  qplu(porec,plevp), 
     *  uplu(porec,plevp),  vplu(porec,plevp),
     *  aplu(porec,plevp,ptrace)

      dimension
     *  zaold(porec),       zanew(porec),
     *  zwold(porec),       zwnew(porec)

      dimension
     *  heipbl(porec),      laypbl(porec),     npbl(plev), 
     *  heip03(plon,porec), heip15(plon,porec)
      character*3 chapbl(plev)
      logical ifheip03, ifheip15

      dimension
     *  qrat(plev), nqrat(plev), qneg(plev), nqneg(plev)

c ---------------------------------------------------------------------
      parameter 
     *  (zaru_pbl = .01,
     *   zars_pbl = .01,
     *   zeff_pbl = 1.,
     *   zrad_pbl = 200.,
     *   zent_pbl = 0.1/zrad_pbl, 
     *   zdra_pbl = 1./(3.1415927*zrad_pbl))
      parameter
     *  (zaro_ca  = .01,
     *   zrad_ca  = 500., 
     *   zent_ca  = 0.1/zrad_ca , 
     *   zdra_ca  = 1./(3.1415927*zrad_ca))
c ---------------------------------------------------------------------
      include 'comsatplume'
c ---------------------------------------------------------------------

      zptot = 0.
      zetot = 0.
      zqtot = 0.
      call reseti (npbl, nlev, 0)
 
      ztodt = twodt
      if (nstep.eq.0) ztodt = 0.5*twodt

      nlevp = nlev+1

      if (icode.eq.0) then
        zareu = zaru_pbl
        zares = zars_pbl
        zent = zent_pbl
        zdrag = zdra_pbl
      else
        zareo = zaro_ca
        zent = zent_ca
        zdrag = zdra_ca
      endif
 7770 if (xzent.ge.0.) zent = xzent

c        Overall loop over longitude

c-----
      do 1000 ji=1,nlon
c-----

c        Set flags whether to update history pbl heights for 03:00h
c        or 15:00h local times

      ifheip03 = .false.
      ifheip15 = .false.

      tlocal = amod ( nstep*dtime + 86400.*along(ji)/(2.*3.1415927),
     *                86400. )
      if (abs(tlocal- 3.00*3600.).le.0.5*dtime .or. nstep.eq.nrstrt)
     *  ifheip03 = .true.
      if (abs(tlocal-15.00*3600.).le.0.5*dtime .or. nstep.eq.nrstrt)
     *  ifheip15 = .true.

c         Calculate ambient pot.temp and density at layer midpoints

      do 100 jk=1,nlev
        do 102 jj=1,norec
          yh(jj,jk) = yt(ji,jj,jk) / sigkpk(jk)
          yrho(jj,jk) = sig(jk)*yps(ji,jj)
     *                / (rair*(1.+zvir*yq(ji,jj,jk))*yt(ji,jj,jk))
  102   continue
  100 continue

c        Interpolate ambient quantities to layer boundaries

      do 110 jk=1,nlevp
        if (jk.eq.1 .or. jk.eq.nlevp) then

          jkm = max (jk-1,1)
          do 112 jj=1,norec
            yhint(jj,jk) = yh(jj,jkm)
            yqint(jj,jk) = yq(ji,jj,jkm)
            yuint(jj,jk) = yu(ji,jj,jkm)
            yvint(jj,jk) = yv(ji,jj,jkm)
            yrhoint(jj,jk)= yrho(jj,jkm)
  112     continue
          do 1120 n=1,ntrace
            do 1122 jj=1,norec
              yaint(jj,jk,n) = tracer(ji,jj,jkm,n)
 1122       continue
 1120     continue

        else

          wei = (sig(jk)-sigkmh(jk)) / (sig(jk)-sig(jk-1))
          do 114 jj=1,norec
            yhint(jj,jk) = wei*yh(jj,jk-1)    + (1.-wei)*yh(jj,jk)
            yqint(jj,jk) = wei*yq(ji,jj,jk-1) + (1.-wei)*yq(ji,jj,jk)
            yuint(jj,jk) = wei*yu(ji,jj,jk-1) + (1.-wei)*yu(ji,jj,jk)
            yvint(jj,jk) = wei*yv(ji,jj,jk-1) + (1.-wei)*yv(ji,jj,jk)
            yrhoint(jj,jk) = sigkmh(jk)*yps(ji,jj)
     *                     / ( rair*(1.+zvir*yqint(jj,jk))
     *                             *yhint(jj,jk)*sigipk(jk) )
  114     continue
          do 1140 n=1,ntrace
            do 1142 jj=1,norec
              yaint(jj,jk,n) =     wei *tracer(ji,jj,jk-1,n)
     *                       + (1.-wei)*tracer(ji,jj,jk,n)
 1142       continue
 1140     continue

        endif
  110 continue
          
c        Compute ambient dz, d*/dz for full layers. For bottom layer,
c        just use top half of layer.

      do 120 jk=1,nlev
        do 122 jj=1,norec
          dztot(jj,jk) = dsigma(jk)*yps(ji,jj) / (gravit*yrho(jj,jk))
          if (jk.eq.nlev) then
            dz(jj,jk) = dztot(jj,jk) * (sig(jk)-sigkmh(jk))/dsigma(jk)
          else
            dz(jj,jk) = dztot(jj,jk)
          endif
          dhdz(jj,jk) = (yhint(jj,jk)-yhint(jj,jk+1)) / dz(jj,jk)
          dqdz(jj,jk) = (yqint(jj,jk)-yqint(jj,jk+1)) / dz(jj,jk)
          dudz(jj,jk) = (yuint(jj,jk)-yuint(jj,jk+1)) / dz(jj,jk)
          dvdz(jj,jk) = (yvint(jj,jk)-yvint(jj,jk+1)) / dz(jj,jk)
  122   continue

        do 1220 n=1,ntrace
          do 1222 jj=1,norec
            dadz(jj,jk,n) = (yaint(jj,jk,n)-yaint(jj,jk+1,n)) /dz(jj,jk)
 1222     continue
 1220   continue
  120 continue
          
c        Compute ambient dz and d*/dz for top halves of layers

      do 130 jk=1,nlev
        do 132 jj=1,norec
          dz2(jj,jk) = (sig(jk)-sigkmh(jk))*yps(ji,jj)
     *               / (gravit*yrho(jj,jk))
          dhdz2(jj,jk) = (yhint(jj,jk)-yh(jj,jk))    / dz2(jj,jk)
          dqdz2(jj,jk) = (yqint(jj,jk)-yq(ji,jj,jk)) / dz2(jj,jk)
          dudz2(jj,jk) = (yuint(jj,jk)-yu(ji,jj,jk)) / dz2(jj,jk)
          dvdz2(jj,jk) = (yvint(jj,jk)-yv(ji,jj,jk)) / dz2(jj,jk)
  132   continue

        do 1320 n=1,ntrace
          do 1322 jj=1,norec
            dadz2(jj,jk,n) = (yaint(jj,jk,n)-tracer(ji,jj,jk,n))
     *                     / dz2(jj,jk)
 1322     continue
 1320   continue
  130 continue

c        Initialize all plume variables to zero, and diagnostic pbl
c        location to lowest-layer mid-point

      call zero (zw,   norec*nlevp)
      call zero (zws,  norec*nlevp)
      call zero (zt,   norec*nlevp)
      call zero (zh,   norec*nlevp)
      call zero (zq,   norec*nlevp)
      call zero (zu,   norec*nlevp)
      call zero (zv,   norec*nlevp)
      call zero (zrho, norec*nlevp)
      call zero (za,   norec*nlevp*ntrace)
      call zero (zarea,norec*nlevp)

      call zero (zlath,norec*nlev)
      call zero (zprec,norec*nlev)

      do 140 jj=1,norec
        heipbl(jj) = dztot(jj,nlev)-dz2(jj,nlev)
        laypbl(jj) = nlev
  140 continue

c       For "pbl" calls, set initial plume conditions at midpoint of 
c       bottom layer based on surface fluxes from constant-flux layer

      if (icode.eq.0) then
        do 150 jj=1,norec
          zz = max (0., min (1., (ytflx(ji,jj)+5.)/10. ))
          zarea(jj,nlevp) = (1.-zz)*zares + zz*zareu 

          ztau = sqrt (yuflx(ji,jj)**2 + yvflx(ji,jj)**2)
          ztauv = max (.01, sqrt(ztau/yrho(jj,nlev)) )
          zconv = ( (max(ytflx(ji,jj),0.)/(yrho(jj,nlev)*cpair))
     *              * rair * (1.-sig(nlev))
     *            ) ** (1./3.)

c-------------------
c777: Before 5/22/92:
c777      zwt = ytflx(ji,jj) / (cpair*yrho(jj,nlev)*zarea(jj,nlevp))
c         zw(jj,nlevp) = max (ztauv, (abs(zwt))**(1./3.))
c         zt(jj,nlevp) = zwt / zw(jj,nlevp)
c         if (abs(zt(jj,nlevp)).gt.10.) then
c           zt(jj,nlevp) = min (10., max(-10., zt(jj,nlevp)))
c           zw(jj,nlevp) = zwt / zt(jj,nlevp)
c         endif
c         zmass = zarea(jj,nlevp) * yrho(jj,nlev) * zw(jj,nlevp)
c         zq(jj,nlevp) = yqflx(ji,jj) / zmass
c         zu(jj,nlevp) = yuflx(ji,jj) / zmass
c         zv(jj,nlevp) = yvflx(ji,jj) / zmass
c-------------------
c777: After 5/22/92:
          zfac = zeff_pbl / zarea(jj,nlevp)
          zwt = max(ytflx(ji,jj),0.) / (yrho(jj,nlev)*cpair)
          zw(jj,nlevp) = sqrt(zfac) * max(ztauv,zconv) 
          zt(jj,nlevp) = zfac*zwt / zw(jj,nlevp)
          if (abs(zt(jj,nlevp)).gt.10.) then
            zt(jj,nlevp) = min (10., max(-10., zt(jj,nlevp)))
            zw(jj,nlevp) = zfac*zwt / zt(jj,nlevp)
          endif
          zq(jj,nlevp)= zfac*yqflx(ji,jj) / (yrho(jj,nlev)*zw(jj,nlevp))
          zu(jj,nlevp)= zfac*yuflx(ji,jj) / (yrho(jj,nlev)*zw(jj,nlevp))
          zv(jj,nlevp)= zfac*yvflx(ji,jj) / (yrho(jj,nlev)*zw(jj,nlevp))
c-------------------

          zh(jj,nlevp) = zt(jj,nlevp) / sigkpk(nlev)

          zws(jj,nlevp)= zw(jj,nlevp)**2
          zrho(jj,nlevp)= sig(nlev)*yps(ji,jj)
     *                  / ( rair*(1.+zvir*(zq(jj,nlevp)+yq(ji,jj,nlev)))
     *                          *(zt(jj,nlevp)+yt(ji,jj,nlev)) )
  150   continue
      endif
           
c        Integrate plumes upwards through each layer (except top one)

      do 200 jk=nlev,2,-1
        jkp = jk+1

c          Integrate main plume (from below) through current layer

        do 210 jj=1,norec
          if (zw(jj,jkp).gt.0.) then
            zexp = exp(-zent*dz(jj,jk))
            zh(jj,jk) = zh(jj,jkp)*zexp - (dhdz(jj,jk)/zent)*(1.-zexp)
            zq(jj,jk) = zq(jj,jkp)*zexp - (dqdz(jj,jk)/zent)*(1.-zexp)
            zu(jj,jk) = zu(jj,jkp)*zexp - (dudz(jj,jk)/zent)*(1.-zexp)
            zv(jj,jk) = zv(jj,jkp)*zexp - (dvdz(jj,jk)/zent)*(1.-zexp)
            zt(jj,jk) = zh(jj,jk)*sigipk(jk)

c              For "c.a." calls, test for parcel saturation, and
c              condense amount that results in exactly saturated air.
c              Store amount in zprec. zlath is latent heat of 
c              condensation, determined by ambient level temperature
c              (ie, rain or snow), plus correction for specific heats
c              to be consistent with lsx (imagining all phase changes
c              occur at tmelt).

            delqn = 0.
            if (icode.ne.0) then
              ztabs = (zh(jj,jk)+yhint(jj,jk))*sigipk(jk)
              zqabs = (zq(jj,jk)+yqint(jj,jk))
              zqsat = qstblf (ztabs, sigkmh(jk)*yps(ji,jj))
              if (zqabs.gt.zqsat) then
                zlath(jj,jk) = cvmgt ( latvap + cpwv*(ztabs-tmelt)
     *                                 - ch2o*(yt(ji,jj,jk)-tmelt),
     *                                 latsub + cpwv*(ztabs-tmelt)
     *                                 - cice*(yt(ji,jj,jk)-tmelt),
     *                                 yt(ji,jj,jk).ge.tmelt )
                dqz = (zlath(jj,jk)/rh2o) * zqsat / (ztabs**2)
                cpz = cpair*(1.+cpvir*zqabs)
                delq = (zqabs-zqsat) / (1.+dqz*zlath(jj,jk)/cpz)
                delqn = delq / (1.-zqabs)
                zqnew = zqabs - delq
                ztnew = ztabs + delqn*zlath(jj,jk)
     *                          / (cpair*(1.+cpvir*zqnew))
                zq(jj,jk) = zqnew - yqint(jj,jk)
                zh(jj,jk) = ztnew/sigipk(jk) - yhint(jj,jk)
                zt(jj,jk) = zh(jj,jk)*sigipk(jk)
              endif
            endif

            zrho(jj,jk) = sigkmh(jk)*yps(ji,jj)
     *                  / ( rair*(1.+zvir*(zq(jj,jk)+yqint(jj,jk)))
     *                          *(zh(jj,jk)+yhint(jj,jk))*sigipk(jk) )

            drho0 = gravit * (yrhoint(jj,jkp)-zrho(jj,jkp))/zrho(jj,jkp)
            drho1 = gravit * (yrhoint(jj,jk) -zrho(jj,jk) )/zrho(jj,jk) 
            a_rho =  (drho0 + (drho1-drho0)/(1.-zexp)) / zent
            b_rho = -(        (drho1-drho0)/(1.-zexp)) / zent
            
            zexp2 = zexp*zexp
c           or: include vertical drag
c           zexp2 = exp(-2.*(zent+zdrag)*dz(jj,jk))
c           a_rho = a_rho * zent / (zent+zdrag)
c           b_rho = b_rho * zent / (2.*(zent+zdrag)-zent)

            zws(jj,jk) = zws(jj,jkp)*zexp2
     *                 + a_rho*(1.-zexp2) + 2.*b_rho*(zexp-zexp2)
            zw(jj,jk) = sqrt ( max(zws(jj,jk),0.) )

c              If vertical velocity = 0, end of main plume;
c              else, re-compute zu and zv for (non-linear) form drag

            if (zw(jj,jk).eq.0.) then
              zh(jj,jk) = 0.
              zq(jj,jk) = 0.
              zu(jj,jk) = 0.
              zv(jj,jk) = 0.
              zt(jj,jk) = 0.
              zrho(jj,jk) = 0.
              zarea(jj,jk) = 0.
              zprec(jj,jk) = 0.
              zlath(jj,jk) = 0.

c             Solve quadratic eqn for exp(-zent*z), ie, for z where w=0,
c             for accurate increment to pbl height (diagnostic only).
c             Only valid for no vertical drag (zdrag=0).
              zz1 = zws(jj,jkp) - a_rho - 2.*b_rho
c             Fudge to avoid quadratic singularity:
              zz1 = cvmgt (zz1, zz1+1.e-9, abs(zz1).gt.1.e-10)
              zz2 = ( -b_rho + sqrt(b_rho**2-zz1*a_rho) ) / zz1
              heipbl(jj)= heipbl(jj) -alog(zz2)/zent
              laypbl(jj) = jk
              zws(jj,jk) = 0.
7771          write(*,*)
     *           ' heipbl=',heipbl(jj),
     *           ' drho=', drho,
     *           ' delt_z=', -alog(zz2)/zent
              write(iuout,*)
     *           ' heipbl=',heipbl(jj),
     *           ' drho=', drho,
     *           ' delt_z=', -alog(zz2)/zent

            else

              zenu = zent + zdrag*abs(0.5*(zu(jj,jkp)+zu(jj,jk)))
     *                    / (0.5*(zw(jj,jkp)+zw(jj,jk)))
              zenv = zent + zdrag*abs(0.5*(zv(jj,jkp)+zv(jj,jk)))
     *                    / (0.5*(zw(jj,jkp)+zw(jj,jk)))
              zexu  = exp(-zenu*dz(jj,jk))
              zexv  = exp(-zenv*dz(jj,jk))
              zu(jj,jk) = zu(jj,jkp)*zexu - (dudz(jj,jk)/zenu)*(1.-zexu)
              zv(jj,jk) = zv(jj,jkp)*zexv - (dvdz(jj,jk)/zenv)*(1.-zexv)

c             Apply continuity condition (detrainment >= 0), imagining
c             plume consists of spherical bubbles with varying vertical
c             spacing mimicked by varying zarea
              zz = (zrho(jj,jkp)*zw(jj,jkp)) / (zrho(jj,jk)*zw(jj,jk))
              zarea(jj,jk) = zarea(jj,jkp) * min (1., zz/zexp)

              zprec(jj,jk) = zarea(jj,jk)*zrho(jj,jk)*zw(jj,jk)*delqn

              heipbl(jj) = heipbl(jj) + dz(jj,jk)
7772          write(*,*)
     *           ' heipbl=',heipbl(jj),
     *           ' drho=', drho,
     *           ' delt_z=', dz(jj,jk)
              write(iuout,*)
     *           ' heipbl=',heipbl(jj),
     *           ' drho=', drho,
     *           ' delt_z=', dz(jj,jk)
            endif
          endif
  210   continue

c          In same way, integrate main-plume tracers through curr layer

        do 2100 n=1,ntrace
          do 2102 jj=1,norec
            if (zw(jj,jkp).gt.0. .and. zw(jj,jk).gt.0.) then
              zexp = exp(-zent*dz(jj,jk))
              za(jj,jk,n) = za(jj,jkp,n)*zexp
     *                    - (dadz(jj,jk,n)/zent)*(1.-zexp)
            else
              za(jj,jk,n) = 0.
            endif
 2102     continue
 2100   continue
              
c          For "c.a." calls, integrate new plume starting from mid-point
c          of current layer.
 
        if (icode.ne.0) then

          do 230 jj=1,norec
            zexp = exp(-zent*dz2(jj,jk))
            zh2(jj) = -(dhdz2(jj,jk)/zent)*(1.-zexp)
            zq2(jj) = -(dqdz2(jj,jk)/zent)*(1.-zexp)
            zu2(jj) = -(dudz2(jj,jk)/zent)*(1.-zexp)
            zv2(jj) = -(dvdz2(jj,jk)/zent)*(1.-zexp)
            zt2(jj) = zh2(jj)*sigipk(jk)

c              Test for saturation as for main plume above

            delqn = 0.
            zprec2(jj) = 0.
            zlath2(jj) = 0.

            ztabs = (zh2(jj)+yhint(jj,jk))*sigipk(jk)
            zqabs = (zq2(jj)+yqint(jj,jk))
            zqsat = qstblf (ztabs, sigkmh(jk)*yps(ji,jj))
            if (zqabs.gt.zqsat) then
              zlath2(jj) = cvmgt ( latvap + cpwv*(ztabs-tmelt)
     *                             - ch2o*(yt(ji,jj,jk)-tmelt),
     *                             latsub + cpwv*(ztabs-tmelt)
     *                             - cice*(yt(ji,jj,jk)-tmelt),
     *                             yt(ji,jj,jk).ge.tmelt )
              dqz = (zlath2(jj)/rh2o) * zqsat / (ztabs**2)
              cpz = cpair*(1.+cpvir*zqabs)
              delq = (zqabs-zqsat) / (1.+dqz*zlath2(jj)/cpz)
              delqn = delq / (1.-zqabs)
              zqnew = zqabs - delq
              ztnew = ztabs + delqn*zlath2(jj)
     *                        / (cpair*(1.+cpvir*zqnew))
              zq2(jj) = zqnew - yqint(jj,jk)
              zh2(jj) = ztnew/sigipk(jk) - yhint(jj,jk)
              zt2(jj) = zh2(jj)*sigipk(jk)
            endif

            zrho2(jj) = sigkmh(jk)*yps(ji,jj)
     *                / ( rair*(1.+zvir*(zq2(jj)+yqint(jj,jk)))
     *                        *(zh2(jj)+yhint(jj,jk))*sigipk(jk) )

            drho = gravit * (yrhoint(jj,jk)-zrho2(jj))/zrho2(jj)
            zws2(jj) = (drho/zent)*(1.-zexp)
c           or: include vertical drag
c           zexp2 = exp(-2.*(zent+zdrag)*dz2(jj,jk))
c           a_rho =   (drho/(1.-zexp)) / (zent+zdrag)
c           b_rho = - (drho/(1.-zexp)) / (2.*(zent+zdrag)-zent)
c           zws2(jj) = a_rho*(1.-zexp2) + 2.*b_rho*(zexp-zexp2)
            zw2(jj) = sqrt ( max(zws2(jj),0.) )

c              If vertical velocity = 0, no new plume;
c              else, re-compute zu2 and zv2 for (non-linear) form drag

            if (zw2(jj).eq.0.) then
              zh2(jj) = 0.
              zq2(jj) = 0.
              zu2(jj) = 0.
              zv2(jj) = 0.
              zt2(jj) = 0.
              zrho2(jj) = 0.
              zprec2(jj) = 0.
              zlath2(jj) = 0.
              zws2(jj) = 0.
            else
              zenu = zent + zdrag*abs(0.5*(zu2(jj))) / (0.5*zw2(jj))
              zenv = zent + zdrag*abs(0.5*(zv2(jj))) / (0.5*zw2(jj))
              zexu  = exp(-zenu*dz2(jj,jk))
              zexv  = exp(-zenv*dz2(jj,jk))
              zu2(jj) = -(dudz(jj,jk)/zenu)*(1.-zexu)
              zv2(jj) = -(dvdz(jj,jk)/zenv)*(1.-zexv)
              zprec2(jj) = zareo*zrho2(jj)*zw2(jj)*delqn
            endif

  230     continue

c            In same way, integrate new-plume tracers from mid-point

          do 2300 n=1,ntrace
            do 2302 jj=1,norec
              if (zw2(jj).gt.0.) then
                zexp = exp(-zent*dz2(jj,jk))
                za2(jj,n) = -(dadz2(jj,jk,n)/zent)*(1.-zexp)
              else
                za2(jj,n) = 0.
              endif
 2302       continue
 2300     continue

c            Merge new plume into main plume

          do 235 jj=1,norec
           if (zw2(jj).gt.0.) then
             zprecnew = zprec(jj,jk) + zprec2(jj)
             zlath(jj,jk) = (  zprec(jj,jk)*zlath(jj,jk)
     *                       + zprec2(jj)  *zlath2(jj)   )
     *                    / max (zprecnew, 1.e-20)
             zprec(jj,jk) = zprecnew

             zaold(jj) = zarea(jj,jk)
             zwold(jj) = zw(jj,jk)
             zanew(jj) = zaold(jj) + zareo
             zwnew(jj) = (zaold(jj)*zwold(jj)+zareo*zw2(jj)) / zanew(jj)

             zh(jj,jk) =
     *        (zaold(jj)*zwold(jj)*zh(jj,jk) + zareo*zw2(jj)*zh2(jj))
     *        / (zanew(jj)*zwnew(jj))
             zq(jj,jk) =
     *        (zaold(jj)*zwold(jj)*zq(jj,jk) + zareo*zw2(jj)*zq2(jj))
     *        / (zanew(jj)*zwnew(jj))
             zu(jj,jk) =
     *        (zaold(jj)*zwold(jj)*zu(jj,jk) + zareo*zw2(jj)*zu2(jj))
     *        / (zanew(jj)*zwnew(jj))
             zv(jj,jk) =
     *        (zaold(jj)*zwold(jj)*zv(jj,jk) + zareo*zw2(jj)*zv2(jj))
     *        / (zanew(jj)*zwnew(jj))

c               Limit merged zarea in case of multiple merges, and
c               adjust vertical velocity zw accordingly.

             zarea(jj,jk) = min (zanew(jj), 5*zareo, .5)
             zw(jj,jk) = zwnew(jj) * zanew(jj) / zarea(jj,jk)

             zws(jj,jk) = zw(jj,jk)**2
             zt(jj,jk) = zh(jj,jk)*sigipk(jk)
             zrho(jj,jk) = sigkmh(jk)*yps(ji,jj)
     *                   / ( rair*(1.+zvir*(zq(jj,jk)+yqint(jj,jk)))
     *                           *(zh(jj,jk)+yhint(jj,jk))*sigipk(jk) )
           endif
  235     continue

c            In same way, merge new-plume tracers into main plume

          do 2350 n=1,ntrace
            do 2352 jj=1,norec
              if (zw2(jj).gt.0.) then
                za(jj,jk,n) = (  zaold(jj)*zwold(jj)*za(jj,jk,n)
     *                         + zareo*zw2(jj)*za2(jj,n) )
     *                      / (zanew(jj)*zwnew(jj))
              endif
 2352       continue
 2350     continue

        endif

c          Count number of main plumes, and skip out of vertical
c          integration if none left for "pbl" calls.

        numplu = 0
        do 250 jj=1,norec
          if (zw(jj,jk).gt.0.) then
            numplu = numplu + 1
c           Arbitrarily limit zw and/or zarea to satisfy "cfl" condition
c           zarea*zw*timestep <= 0.5 * each adjacent layer thickness:
c           zw(jj,jk) = min (zw(jj,jk), 15.)
c           zws(jj,jk) = zw(jj,jk)**2
c           zarea(jj,jk) = min ( zarea(jj,jk), 
c    *                           0.5*min(dztot(jj,jk),dztot(jj,jk-1))
c    *                           / (zw(jj,jk)*ztodt) )
          endif
  250   continue

        if (icode.eq.0 .and. numplu.eq.0) goto 290

  200 continue

c        Compute large-scale fluxes at layer boundaries. 

  290 do 300 jk=1,nlevp
        do 302 jj=1,norec

          if (jk.eq.nlevp) then
            if (icode.eq.0) then
              tplu(jj,jk) = ytflx(ji,jj)
              qplu(jj,jk) = yqflx(ji,jj)
              uplu(jj,jk) = yuflx(ji,jj)
              vplu(jj,jk) = yvflx(ji,jj)
            else 
              tplu(jj,jk) = 0.
              qplu(jj,jk) = 0.
              uplu(jj,jk) = 0.
              vplu(jj,jk) = 0.
            endif
          else
            zmass = zarea(jj,jk)*zrho(jj,jk)*zw(jj,jk)
            tplu(jj,jk) = zt(jj,jk)*zmass*cpair
            qplu(jj,jk) = zq(jj,jk)*zmass
            uplu(jj,jk) = zu(jj,jk)*zmass
            vplu(jj,jk) = zv(jj,jk)*zmass
          endif
  302   continue

        do 3020 n=1,ntrace
          do 3022 jj=1,norec
            if (jk.eq.nlevp) then
              aplu(jj,jk,n) = 0.
            else
              zmass = zarea(jj,jk)*zrho(jj,jk)*zw(jj,jk)
              aplu(jj,jk,n) = za(jj,jk,n)*zmass
            endif
 3022     continue
 3020   continue

  300 continue

c        Compute flux convergence into each layer and add to reservoirs
c        fplum* ("flux*time per layer", in commun) for use in vdiff.
c        Use dtime, not ztodt, since reservoirs are not leapfrog 
c        variables (see comments in reserv).
 
      do 320 jk=1,nlev
        do 322 jj=1,norec
          fplumt(ji,jj,jk) = fplumt(ji,jj,jk)
     *                     + (  tplu(jj,jk+1)-tplu(jj,jk)
     *                        + zprec(jj,jk)*zlath(jj,jk) ) * dtime
          fplumq(ji,jj,jk) = fplumq(ji,jj,jk)
     *                     + (  qplu(jj,jk+1)-qplu(jj,jk)
     *                        - zprec(jj,jk)              ) * dtime
          fplumu(ji,jj,jk) = fplumu(ji,jj,jk)
     *                     + (  uplu(jj,jk+1)-uplu(jj,jk) ) * dtime
          fplumv(ji,jj,jk) = fplumv(ji,jj,jk)
     *                     + (  vplu(jj,jk+1)-vplu(jj,jk) ) * dtime

          zqtot = zqtot
     *          + (qplu(jj,jk+1)-qplu(jj,jk))*ztodt*cosbud(jj)/nlon
          zptot = zptot + zprec(jj,jk)*ztodt*cosbud(jj)/nlon
          if (icode.eq.0 .and. jk.eq.1)
     *      zetot = zetot + yqflx(ji,jj)*ztodt*cosbud(jj)/nlon
  322   continue

        do 3220 n=1,ntrace
          do 3222 jj=1,norec
            fplumtra(ji,jj,jk,n) = fplumtra(ji,jj,jk,n)
     *                     + (  aplu(jj,jk+1,n)-aplu(jj,jk,n) ) * dtime
 3222     continue
 3220   continue
  320 continue


c        For "c.a." calls, accumulate condensation heating rate (qct2,
c        W/m2), convective precip formation rate (convpra, Kg/m2/s),
c        and budget convective latent heating (dhcdcu, J/m2).

      if (icode.ne.0) then
        do 330 jk=1,nlev
          do 332 jj=1,norec
            qct2(ji,jj,jk) = qct2(ji,jj,jk) 
     *                     + zlath(jj,jk)*zprec(jj,jk)
            convpra(ji,jj,jk) = convpra(ji,jj,jk) + zprec(jj,jk)

            if (ntwo.eq.1) then
              dhcdcu = dhcdcu + zprec(jj,jk)*zlath(jj,jk)*dtbud
     *                          *cosbud(jj)/nlon
            endif
  332     continue
  330   continue
      endif

c        For "pbl" calls, set history pbl heights for 03:00h and 15:00h,
c        and accumulate diagnostic number of pbl-tops in each layer
c        (npbl). Also use npbl for "c.a." calls, ie, the number of
c        points in each layer that contain  the highest free convective
c        plume top for that x,y location.

      if (icode.eq.0) then
        if (ifheip03) then
          do 400 jj=1,norec
            heip03(ji,jj) = heipbl(jj)
  400     continue
        endif

        if (ifheip15) then
          do 410 jj=1,norec
            heip15(ji,jj) = heipbl(jj)
  410     continue
        endif
      endif

      do 420 jj=1,norec
        npbl(laypbl(jj)) = npbl(laypbl(jj)) + 1
  420 continue

c        Diagnostic printout: vertical profile at one point for "pbl"

c7773 if (nstep.gt.nstop-48 .and. ji.eq.48 .and. icode.eq.0) then
 7773 if (icode.eq.0) then
cc      zzmax = -1.e20
cc      do 8880 jk=1,nlev
cc      do 8880 jj=1,norec
cc        if (zw(jj,jk).gt.zzmax) then
cc          jjm =jj
cc          zzmax = zw(jj,jk)
cc        endif
c8880    continue
cc      jjm = 25
        jjm = 1
        write(*,8882) nstep*dtime/86400., ji, jjm, icode,
     *   (jk, sigkmh(jk), zarea(jjm,jk), zw(jjm,jk),
     *        zt(jjm,jk), zq(jjm,jk), zrho(jjm,jk),
     *        yhint(jjm,jk), yqint(jjm,jk),yrhoint(jjm,jk),
     *        tplu(jjm,jk), qplu(jjm,jk)*.864e5,
     *    jk=nlevp,1,-1)
        write(iuout,8882) nstep*dtime/86400., ji, jjm, icode,
     *   (jk, sigkmh(jk), zarea(jjm,jk), zw(jjm,jk),
     *        zt(jjm,jk), zq(jjm,jk), zrho(jjm,jk),
     *        yhint(jjm,jk), yqint(jjm,jk),yrhoint(jjm,jk),
     *        tplu(jjm,jk), qplu(jjm,jk)*.864e5,
     *    jk=nlevp,1,-1)
 8882   format( ' day=',f8.3,'  ji=',i3,'   jj=',i3,'   icode =',i3
     *         /' jk',4x,'sig',5x,'zarea',8x,'zw',
     *                8x,'zt',8x,'zq',6x,'zrho',
     *                5x,'yhint',5x,'yqint',3x,'yrhoint',
     *                6x,'tplu',6x,'qplu',
     *         /(i3,f7.3,10f10.5))
      endif

c        Diagnostic printout: vertical profile at one point for "c.a."

c7774 if (nstep.gt.nstop-48 .and. ji.eq.48 .and. icode.eq.1) then
 7774 if (icode.eq.1) then
cc      zzmax = -1.e20
cc      do 8880 jj=1,norec
cc        zz = 0.
cc        do 8881 jk=1,nlev
cc          if (zprec(jj,jk).gt.0.) zz = zz + 1.
c8881     continue
cc        if (zz.gt.zzmax) then
cc          jjm =jj
cc          zzmax = zz
cc        endif
c8880   continue
        jjm = 1
        write(*,8883) nstep*dtime/86400., ji, jjm, icode,
     *   (jk, sigkmh(jk), zarea(jjm,jk), zw(jjm,jk),
     *        zt(jjm,jk), zq(jjm,jk), zrho(jjm,jk),
     *        yhint(jjm,jk), yqint(jjm,jk),yrhoint(jjm,jk),
     *        tplu(jjm,jk), qplu(jjm,jk)*.864e5,
     *        yq(ji,jjm,min(jk,nlev)), zprec(jjm,min(jk,nlev))*.864e5,
     *    jk=nlevp,1,-1)
        write(iuout,8883) nstep*dtime/86400., ji, jjm, icode,
     *   (jk, sigkmh(jk), zarea(jjm,jk), zw(jjm,jk),
     *        zt(jjm,jk), zq(jjm,jk), zrho(jjm,jk),
     *        yhint(jjm,jk), yqint(jjm,jk),yrhoint(jjm,jk),
     *        tplu(jjm,jk), qplu(jjm,jk)*.864e5,
     *        yq(ji,jjm,min(jk,nlev)), zprec(jjm,min(jk,nlev))*.864e5,
     *    jk=nlevp,1,-1)
 8883   format( ' day=',f8.3,'  ji=',i3,'   jj=',i3,'   icode =',i3
     *         /' jk',4x,'sig',5x,'zarea',8x,'zw',
     *                8x,'zt',8x,'zq',6x,'zrho',
     *                5x,'yhint',5x,'yqint',3x,'yrhoint',
     *                6x,'tplu',6x,'qplu',
     *                6x,'newq',5x,'zprec'
     *         /(i3,f7.3,12f10.5))
      endif

c        Diagnostic printout: one line for one point for "pbl"

c7775 if (icode.eq.0 .and. nstep.gt.nstop-96 .and. nstep.le.nstop-48 
c7775* .and. ji.eq.48) then
 7775 if (icode.eq.0) then
cc       jj=25
         jj=1
         do 8884 jk=1,nlev
           chapbl(jk) = '   '
 8884    continue
         chapbl(laypbl(jj)) = '***'
         if (mod(nstep,48).eq.1) then
           write(*,8885) ji,jj
           write(iuout,8885) ji,jj
 8885      format(/' ji,jj=',2i3
     *            /5x,'day',2x,'heipbl',3x,'ytflx',
     *             5x,5(6x,'yh',1x),5x,5(6x,'yq',1x) )
         endif
         write(*,8886) nstep*dtime/86400., heipbl(jj), ytflx(ji,jj),
     *    (yt(ji,jj,jk)/sigkpk(jk),chapbl(jk)(1:1), jk=nlev,nlev-4,-1),
     *    (yq(ji,jj,jk),chapbl(jk)(1:1), jk=nlev,nlev-4,-1)
         write(iuout,8886) nstep*dtime/86400., heipbl(jj), ytflx(ji,jj),
     *    (yt(ji,jj,jk)/sigkpk(jk),chapbl(jk)(1:1), jk=nlev,nlev-4,-1),
     *    (yq(ji,jj,jk),chapbl(jk)(1:1), jk=nlev,nlev-4,-1)
 8886    format(f8.3,f8.1,f8.1,5x,5(f8.2,a1),5x,5(f8.5,a1))
      endif
 
c        End of overall loop over longitude

c-----
 1000 continue
c-----

c        For "pbl" calls, save 03:00h and 15:00h history pbl heights

      if (icode.eq.0) then
        call puthis (heip03, 63)
        call puthis (heip15, 64)
      endif
      
c        Diagnostic printout: number of negative q's globally vs level

      zz = ztodt / (3.*3600.)
      qnegmax = 1.e20
      nqnegtot = 0
      do 8890 jk=1,nlev
        qrat(jk) = 0.
        qneg(jk) = 0.
        nqrat(jk) = 0
        nqneg(jk) = 0
        do 8891 jj=1,norec
        do 8891 ji=1,nlon
          dqnew = zz * fplumq(ji,jj,jk) / (dsigma(jk)*yps(ji,jj)/gravit)
          if (abs(yq(ji,jj,jk)).gt.0.00005) then
            qrat(jk) = qrat(jk) + abs(dqnew) / abs(yq(ji,jj,jk))
            nqrat(jk) = nqrat(jk) + 1
          endif
          qnew = yq(ji,jj,jk) + dqnew
          if (qnew.lt.0.) then
            qneg(jk) = qneg(jk) + qnew
            nqneg(jk) = nqneg(jk) + 1
            nqnegtot = nqnegtot + 1
            if (qnew.lt.qnegmax) then
              qnegmax = qnew
              jkmax = jk
              jimax = ji
              jjmax = jj
            endif
          endif
 8891   continue
        if (nqrat(jk).gt.0) qrat(jk) = qrat(jk)/nqrat(jk)
        if( nqneg(jk).gt.0) qneg(jk) = qneg(jk)/nqneg(jk)
 8890 continue
      if (nqnegtot.gt.0) then
        write(*,8892) nstep, icode, zptot, zetot, zqtot,
     *                qnegmax, jimax,jjmax,jkmax,
     *                nqrat(jkmax),qrat(jkmax),nqneg(jkmax),qneg(jkmax)
        write(iuout,8892) nstep, icode, zptot, zetot, zqtot,
     *                qnegmax, jimax,jjmax,jkmax,
     *                nqrat(jkmax),qrat(jkmax),nqneg(jkmax),qneg(jkmax)
 8892   format(/' nstep=',i8,'   icode=',i3,
     *          '   zptot=',f10.5,'   zetot=',f10.5,'   zqtot=',f10.5
     *         /' qnegmax=',f10.5,'  at',3i4
     *         /' nqrat=',i4,'   qrat=',f9.6,
     *          '   nqneg=',i4,'   qneg=',f9.6) 
      endif

c        Diagnostic printout: max heip15, npbl

c     if (icode.eq.0 .and. nstep.gt.nstop-48) then
c       zz = -1.e20
c       do 8895 jj=1,norec
c       do 8895 ji=1,nlon
c         if (heip15(ji,jj).gt.zz) then
c           izz = ji
c           jzz = jj
c           zz = heip15(ji,jj)
c         endif
c8895   continue
c       write(*,8896) nstep*dtime/86400., zz, izz, jzz, 
c    *                (npbl(jk),jk=nlev,1,-1) 
c8896   format(' day=',f8.3,'  heip15=',f8.1,'  at ji,jj=',2i3,
c    *         '  npbl=',(12i5))
c     endif
      
c        Diagnostic printout: number of pbl tops (for "pbl" calls),
c        or free plume tops (for "c.a." calls), in each layer, 
c        written to fort.87 and fort.88

c7776 if ( mod(nstep,nint(1.*86400./dtime)) .eq. 0 ) then
 7776 if (icode.eq.1) then
cc      iu = 87+icode
        iu = 6
        write(iu,8897)
     *    icode,nstep*dtime/86400., (npbl(jk),jk=nlev,1,-1)
        write(iuout,8897)
     *    icode,nstep*dtime/86400., (npbl(jk),jk=nlev,1,-1)
 8897   format(' plume: icode=',i2,' day=',f8.3,' npbl=',(12i5))
      endif

      return
      end
c
c ***************************** reevap *********************************
c
      subroutine reevap (yt, yq, yps, precipa, 
     *                   fplumt, fplumq, qct2, precip, frain, fsnow, 
     *                   dhcd, icode)

c     Does re-evaporation of falling precipitation. Called separately
c     for convective and stratiform precip, to allow (i) diagnostics and
c     (ii) different reevap fractions of originating precip (see below).
c     As precip enters a layer from above, its sensible heat and phase
c     are adjusted to that layer's temperature and the associated heat
c     flux given to fplumt for that layer. Then a fraction of the precip
c     re-evaporates or sublimates within that layer proportional to the
c     ambient dryness (qsat-q), using a conceptual model with fixed
c     fall velocities, transfer coeffs and drop radii. Another fraction
c     is used for reevap of precip *originating* in that layer. This
c     is larger than for falling precip to crudely represent in-situ
c     clouds...here we are anticipating the in-situ re-evaporation
c     of non-precipitating clouds. This in-situ fraction can be 
c     different for stratiform and convective clouds; for simplicity its
c     functional dependence on ambient dryness and layer thickness is
c     the same as for falling precip.

c     Supplied:
c     yt      = agcm temperatures (deg K)
c     yq      = agcm specific humidity (kg/kg)
c     yps     = agcm surface pressure (N/m2)
c     precipa = 3-D precip formation rate (strat or conv) (kg/m2/s)
c     icode   = 0 for stratiform, 1 for convective

c     Modified (incremented):
c     fplum* = reservoirs of "flux convergence*time" in each agcm layer
c              (J/m2 for fplumt, kg/m2 for fplumq)
c     qct2   = net 3-D condensation heating rate (W/m2)
c     precip = precip rate at ground (strat or conv) (kg/m2/s)
c     frain  = rainfall rate at ground (kg/m2/s)
c     fsnow  = snowfall rate at ground (kg/m2/s)
c     dhcd   = global re-evap cooling budget (dhcdcur or dhcdstr) (J/m2)

c ---------------------------------------------------------------------
      include 'complume'
c ---------------------------------------------------------------------
      dimension 
     *  yt(plon,porec,plev),      yq(plon,porec,plev),
     *  yps(plon,porec),          precipa(plon,porec,plev), 

     *  fplumt(plon,porec,plev),  fplumq(plon,porec,plev),
     *  qct2(plon,porec,plev),    precip(plon,porec),       
     *  frain(plon,porec),        fsnow(plon,porec)

      dimension
     *  zdqsat(plon),  zrho(plon),    zdz(plon),
     *  zfacp(plon),   zfaco(plon),   zlath(plon),   zch(plon),
     *  zprec(plon),   zdprec(plon),  zcoolp(plon),
     *  zorig(plon),   zdorig(plon),  zcoolo(plon),
     *  za(plon),      zb(plon)
c ---------------------------------------------------------------------
c  zevp    is a factor in the re-evap fraction of falling precip,
c  zevo_st is the same for originating stratiform precip,
c  zevo_cu is the same for originating convective precip.
c777  parameter (zevp=0.4, zevo_st=0.4, zevo_cu=0.4)
c777  parameter (zevp=0.4, zevo_st=0.4, zevo_cu=2.0)
 777  parameter (zevp=0.0, zevo_st=0.0, zevo_cu=0.0)
c ---------------------------------------------------------------------
      include 'comsatplume'
c ---------------------------------------------------------------------

c     Initialize diagnostics: global precip formation (zdiagpa) 
c     and precip reaching ground (zdiagpg)

      zdiagpa = 0.
      zdiagpg = 0.

c     Outer loop over latitude

c=====
      do 1000 jj=1,norec
c=====

c       Algorithm does one pass from top to bottom layer, one longitude
c       strip at a time.
c         zprec = falling precip (kg/m2/s)
c         zorig = precip originating in current layer (kg/m2/s)

        call zero (zprec,nlon)

c=====
        do 100 jk=1,nlev
c=====

          call scopy (nlon, precipa(1,jj,jk), 1, zorig, 1)

          zprecsum = ssum (nlon,zprec,1)
          zorigsum = ssum (nlon,zorig,1)

c         If no precip entering layer from above and no originating
c         precip (for any longitude), don't do anything. Else set up:
c           zlath = sensible+latent heat for reevap within layer
c                   (as if all phase changes occur at tmelt as in LSX)
c           zfacp = fraction of falling precip reevaped in this  layer
c           zfaco = fraction of originating precip reevaped within layer

c-----
          if (zprecsum.ne.0. or. zorigsum.ne.0.) then
c-----
            do 110 ji=1,nlon
              zlath(ji) = cvmgt ( latvap + cpwv*(yt(ji,jj,jk)-tmelt)
     *                                   - ch2o*(yt(ji,jj,jk)-tmelt),
     *                            latsub + cpwv*(yt(ji,jj,jk)-tmelt)
     *                                   - cice*(yt(ji,jj,jk)-tmelt),
     *                            yt(ji,jj,jk).ge.tmelt )
              zdqsat(ji) = qstblf (yt(ji,jj,jk), sig(jk)*yps(ji,jj))
     *                   - yq(ji,jj,jk)
              zrho(ji) = sig(jk)*yps(ji,jj)
     *                 / (rair*(1.+zvir*yq(ji,jj,jk))*yt(ji,jj,jk))
              zdz(ji) = dsigma(jk)*yps(ji,jj) / (gravit*zrho(ji))
              zz = zevp * zdz(ji) * max(zdqsat(ji),0.)
              zfacp(ji) = 1.-exp(-zz)
  110       continue

            if (icode.eq.0) then
              do 114 ji=1,nlon
                zz = zevo_st * zdz(ji) *  max(zdqsat(ji),0.)
                zfaco(ji)= 1.-exp(-0.5*zz)
c               zfaco(ji) = cvmgt ( 1.-(1.-exp(-zz))/max(zz,1.e-10),
c    *                              0., zz.gt.1.e-10 )
  114         continue
            else
              do 116 ji=1,nlon
                zz = zevo_cu * zdz(ji) *  max(zdqsat(ji),0.)
                zfaco(ji)= 1.-exp(-0.5*zz)
  116         continue
            endif
c-----
          endif
c-----

c         If any precip entering from above, (i) adjust it to the
c         ambient layer temperature and (ii) re-evaporate fraction
c         zfacp. Give associated heat and vapor fluxes from both
c         processes to the large-scale reservoirs fplum[t,q], and
c         increment diagnostics qct2,dhcd. First set:
c           zch = sensible+latent heat for adjust to layer temperature
c                 (as if all phase changes occur at tmelt as in LSX)

c-----
          if (zprecsum.ne.0.) then
c-----
            jkm = jk - 1
            do 120 ji=1,nlon
              za(ji) = cvmgt (0.5, -0.5, yt(ji,jj,jkm).ge.tmelt)
              zb(ji) = cvmgt (0.5, -0.5, yt(ji,jj,jk) .ge.tmelt)
              zch(ji) = - cvmgt ( ch2o, cice, yt(ji,jj,jkm).ge.tmelt )
     *                          * (yt(ji,jj,jkm)-tmelt)
     *                  + cvmgt ( ch2o, cice, yt(ji,jj,jk) .ge.tmelt )
     *                          * (yt(ji,jj,jk)-tmelt)
     *                  + latice* (zb(ji)-za(ji))

              zdprec(ji) = zprec(ji)*zfacp(ji)
              zcoolp(ji) = zprec(ji)*zch(ji) + zdprec(ji)*zlath(ji)
              fplumq(ji,jj,jk) = fplumq(ji,jj,jk) + zdprec(ji)*dtime
              fplumt(ji,jj,jk) = fplumt(ji,jj,jk) - zcoolp(ji)*dtime
              qct2(ji,jj,jk)   = qct2(ji,jj,jk) - zcoolp(ji)
              zprec(ji) = zprec(ji) - zdprec(ji)
  120       continue

            if (ntwo.eq.1) then 
              zsumh = ssum (nlon,zcoolp,1)
              dhcd = dhcd - (zsumh/nlon)*cosbud(jj)*dtbud
            endif
c-----
          endif
c-----

c         If any precip originating in this layer, re-evaporate
c         fraction zfaco and add the remainder to zprec. Give associated
c         heat and vapor fluxes to the large-scale reservoirs fplum[t,q]
c         and increment diagnostics qct2,dhcd.

c-----
          if (zorigsum.ne.0.) then
c-----
            do 130 ji=1,nlon
              zdorig(ji) = zorig(ji)*zfaco(ji)
              zcoolo(ji) = zdorig(ji)*zlath(ji)
              fplumq(ji,jj,jk) = fplumq(ji,jj,jk) + zdorig(ji)*dtime
              fplumt(ji,jj,jk) = fplumt(ji,jj,jk) - zcoolo(ji)*dtime
              qct2(ji,jj,jk)   = qct2(ji,jj,jk) - zcoolo(ji)
              zorig(ji) = zorig(ji) - zdorig(ji)
  130       continue

            if (ntwo.eq.1) then 
              zsumh = ssum (nlon,zcoolo,1)
              dhcd = dhcd - (zsumh/nlon)*cosbud(jj)*dtbud
            endif

            do 140 ji=1,nlon
              zprec(ji) = zprec(ji) + zorig(ji)
  140       continue
c-----
          endif
c-----

c         Increment diagnostic global precip formation rate

          zdiagpa = zdiagpa + (zorigsum/nlon)*cosbud(jj)

c=====
  100   continue
c=====

c       At this point zprec = precip falling out of bottom of lowest
c       layer, with temperature of lowest layer and phase depending
c       on that temp >= or < tmelt. Increment model precip quantities
c       (precip,frain,fsnow) and diagnostic zdiagpg.

        do 200 ji=1,nlon
          precip(ji,jj) = precip(ji,jj) + zprec(ji)
          frain(ji,jj) = cvmgt ( frain(ji,jj)+zprec(ji), frain(ji,jj),
     *                           yt(ji,jj,nlev).ge.tmelt )
          fsnow(ji,jj) = cvmgt ( fsnow(ji,jj)+zprec(ji), fsnow(ji,jj),
     *                           yt(ji,jj,nlev).lt.tmelt )
  200   continue

        zdiagpg = zdiagpg + (ssum(nlon,zprec,1)/nlon)*cosbud(jj)

c=====
 1000 continue
c=====

c     if ( mod(nstep,nint(1.*86400./dtime)) .eq. 0 ) then
c       if (icode.eq.0) write(*,*)
c       zz = 8.64e7/rhoh2o
c       write(*,900) nstep*dtime/86400., icode,
c    *    zz*zdiagpa, zz*zdiagpg, zz*zdiagpg / max(zz*zdiagpa,1.e-10)
c 900   format(' reevap: day, icode, zdiagpa, zdiagpg, ratio=',
c    *         f10.3,i3,3f10.3)
c     endif

      return
      end
c
c **********************************************************************
c
      subroutine zero (arr, nar)
c
c        zeros nar words starting at arr(1)
c
      dimension arr(nar)
      do 10 j=1,nar
        arr(j) = 0.
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine reseti (iarr, nar, ival)
c
c        sets nar integer words to ival starting at iarr(1)
c
      dimension iarr(nar)
      do 10 j=1,nar
        iarr(j) = ival
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine puthis (arr, icode)
c
c        dummy write to history file
c
      dimension arr(1,1)
      return
      end
c
c **********************************************************************
c
      function cvmgt (vala, valb, test)
      logical test

      if (test) then
        cvmgt = vala
      else
        cvmgt = valb
      endif
      return
      end
c
c **********************************************************************
c
      function ssum (n, arr, inc)
      dimension arr(n)

      ssum = 0.
      do 10 i=1,n,inc
        ssum = ssum + arr(i)
   10 continue
      return
      end
c
c **********************************************************************
c
      function sigma (n, arr, inc)
      dimension arr(n)

      ssum = 0.
      do 10 i=1,n,inc
        ssum = ssum + arr(i)
   10 continue
      return
      end
c
c **********************************************************************
c
      subroutine scopy (n, arr, inca, brr, incb)
      dimension arr(n), brr(n)

      j = 1
      do 10 i=1,n,inca
        brr(j) = arr(i)
        j = j + incb
   10 continue
      return
      end
